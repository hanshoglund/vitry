(do (a b)
   (c d
     (e f)))
(do (a = 1 )
   (print (1 + 2)))
(let (x = 1)
    (y = 2)
    (1 + 2))
(module Vitry.Prelude)
(type
    (nil)
    (true)
    (false)
    (bool = true | false)
    (empty))
(() = nil)
([] = nil)
({} = empty)
(not  (false     = true)
     (true      = false))
((&&) (true true = true)
     (bool bool = false))
((||) (true bool = true)
     (bool true = true)
     (bool bool = false))
(id    (x       = x))
(const (x       = fn (y) x))
((.)   (f g     = fn (x) f (g x)))
((..)  (f g     = g . f))
(iter  (f i     = f . (iter f (i-1)))
      (0 f     = f))
(flip  (f x y z = f y x z))
(type
    (rat     = (nat, nat))
    (complex = (double, double))
    (polar   = (double, double))
    (char    = word16)
    (float   = word32)
    (double  = word64)
    (quad    = word128)
    (str     = [char]))
(type (num    = prec| real))
(type (prec   = nat| int| rat))
(type (real   = float| double| quad| complex))
(implicit
    (bool     -> nat)
    (nat      -> int)
    (float    -> double)
    (n : int    <-> (n, 1) : rat)
    (r : double <-> (r, 0) : complex)
    ((r, t) : polar   -> (r * (cos t), r * (sin t))    : complex)
    ((x, y) : complex -> (sqrt (y^2 + x^2), atan2 y x) : polar))
(sign (1 n = abs n    : num -> num -> num)
     (0 n = -(abs n)))
(zeroth   = error)
(succ     = error)
(pred     = error)
((<)  (x y = error))
((<=) (x y = error))
((>=) (x y = error))
((>)  (x y = error))
(min (x y = if (x < y) x else y)
    ([x] = foldl (<) zeroth [x]))
(max (x y = if (x > y) x else y)
    ([x] = foldl (>) zeroth [x]))
(isOdd (x        = x % 2 == 0))
(isEven (x       = x % 2 == 1))
(isPrime (x      = ...))
(isZero (0       = true)
       (_       = false))
(isPositive (n   = n > 0))
(isNegative     = n < 0)
(isReal ((r, i) = (i == 0) : complex -> bool)
       (num    = true     : num -> bool)
       (_      = false    : a -> bool))
(isNan      (nan = true)
           (_   = false))
(isInfinite (inf = true)
           (_   = false))
(isNumber   (x   = not (isNan x)))
(isFinite   (x   = not (isInfinite x)))
(last    ((x, [])   = x                   : [a] -> a)
        ((x, xs)   = last xs))
(init    ((x, [])   = []                  : [a] -> [a])
        ((x, xs)   = (x, (init xs))))
(append  ([] a      = (a, [])             : [a] -> a -> [a])
        ((x, xs) a = (x, (append a xs))))
(length  ([]        = 0                   : [a] -> nat)
        ((x, xs)   = 1 + (length xs)))
(rank    (xs = fold (xs)))
(isEmpty ([] = true)
        (_  = false))
(isSingle ([_] = true)
         (_   = false))
(nth)
(map)
(foldl)
(foldr)
((++))
(insert)
(substr)
(subseq)
(drop)
(take)
(remove)
(retain)
(reverse)
(sort)
(search)
(shuffle)
(permute)
(partition)
(some)
(every)
(none)
(now)
(read)
(eval)
(print)
(error)
(repl)
(require)
(load)
(version)
(quit)
(infix
    (right+ 12 (.))
    (left   10 (^^))
    (left   10 (^))
    (left   9  (%))
    (left   9  (%%))
    (left   9  (/))
    (left   9  (*))
    (left   8  (-))
    (left   8  (+))
    (left   8  (++))
    (left   6  (<))
    (left   6  (<=))
    (left   6  (>=))
    (left   6  (>))
    (left   6  (/=))
    (left   6  (==))
    (left+  5  [,])
    (left+  5  {,})
    (left+  5  (,))
    (left   4  (|))
    (left   4  (&))
    (right  3  (->))
    (right  2  (&&))
    (right  1  (||))
    (left   0  ($!))
    (right  0  ($)))

