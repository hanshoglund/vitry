; Vitry, copyright (C) Hans Hoglund 2011
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; See COPYING.txt for details.


; First shot at implementation-neutral prelude.
; Includes bootstrap definitions as out-commented lines.
;
; TODO
;   trees/DAGs
;   arrays/matrices
;   regexp-like seq functions
;   concurrency
;   reification
;
; @author Hans

module Vitry.Prelude



; Core types
; Required by the basic constructors.

type
    nil
    True
    False
    Any
    Empty
    Bool = True | False

() = nil
[] = nil
{} = Empty
_  = Any


; Basic constructors
; May be implemented by sequencing and matching prococols.

; (,)       product,      n == 0 || > 1
; [,]       list,         n >= 0
; {,}       set,          n >= 0
; (|)       union,        n > 1
; (&)       Intersection, n > 1
; (->)      function,     n == 2
; (<->)     isomorphism,  n == 2


; Booleans

; Equality is defined in the matching logic, since a == b iff a : b, b : a
; However, implementations should override == to get a faster comparison

; (==) : a -> b -> Bool
; (!=) : not . (==)

not  False     = True
     True      = False
(&&) True True = True
     Bool Bool = False
(||) True Bool = True
     Bool True = True
     Bool Bool = False




; Functions

id    x       = x
const x       = fn (y) x
(.)   f g     = fn (x) f (g x)
(..)  f g     = g . f
iter  f i     = f . (iter f (i-1))
      0 f     = f

flip  f x y z = f y x z
;domain
;range
;arity


; Numbers and strings
; Logically Numbers are no distinct from symbolic values, but implementations
; will of course use underlying machine/VM primitives.

type
  ; Word8   = (Bool, Bool ...)
  ; Word16  = (Bool, Bool ...)
  ; Word32  = (Bool, Bool ...)
  ; Word64  = (Bool, Bool ...)
  ; Word128 = (Bool, Bool ...)
  ; Nat     = 0 | 1 | 2 ...
  ; Int     = Nat | -1 | -2 ...
    Char    = Word16
    Float   = Word32
    Double  = Word64
    Quad    = Word128
    Rat     = (Nat, Nat)
    Complex = (Double, Double)
    Polar   = (Double, Double)
    Str     = [Char]

type Num    = Prec
            | Real
type Prec   = Nat
            | Int
            | Rat
type Real   = Float
            | Double
            | quad
            | Complex

; Numeric conversions

implicit
    Bool     -> Nat
    Nat      -> Int
    Float    -> Double

    n : Int    <-> (n, 1) : Rat
    r : Double <-> (r, 0) : Complex

    (r, t) : Polar   -> (r * (cos t), r * (sin t))    : Complex
    (x, y) : Complex -> (sqrt (y^2 + x^2), atan2 y x) : Polar

; Note that Precise and Real hierarchies are orthogonal
; Some standard library functions are overloaded for Precise
; and Real arithmetic, others assume a specific representation.



sign 1 n = abs n    : Num -> Num -> Num
     0 n = -(abs n)

;
; getBits x:Float
; getBits x:Double
; getBits x:quad



; Special function to lift canonical string representations Into
; the value domain and vice versa. These functions are simple
; subsets of (eval . read) and prInt respectively, and can be
; equally misused.

; symbol : str -> a
; string : a -> str





; Meant to be extended
zeroth   = error
succ     = error
pred     = error
(<)  x y = error
(<=) x y = error
(>=) x y = error
(>)  x y = error

min x y = if (x < y) x else y
    [x] = foldl (<) zeroth [x]
max x y = if (x > y) x else y
    [x] = foldl (>) zeroth [x]






; Arithmetic

; (+)
; (-)
; (*)
; (/)
; (%)
; (%%)
; negate
; abs
; sigNum
; (^)
; sqrt
; log
; logn
; ln
; sin
; tan
; cos
; asin
; atan
; acos
; round
; ceil
; floor
; recip
; sum
; prod
; gcd
; lcm

isOdd x        = x % 2 == 0
isEven x       = x % 2 == 1

isPrime x      = ...

isZero 0       = True
       _       = False

isPositive n   = n > 0
isNegative     = n < 0

isReal (r, i) = (i == 0) : Complex -> Bool
       Num    = True     : Num -> Bool
       _      = False    : a -> Bool

isNan      nan = True
           _   = False
isInfinite inf = True
           _   = False
isNumber   x   = not (isNan x)
isFinite   x   = not (isInfinite x)





; Lists

; head
; tail
; prepend

last    (x, [])   = x                   : [a] -> a
        (x, xs)   = last xs

init    (x, [])   = []                  : [a] -> [a]
        (x, xs)   = (x, (init xs))

append  [] a      = (a, [])             : [a] -> a -> [a]
        (x, xs) a = (x, (append a xs))

length  []        = 0                   : [a] -> Nat
        (x, xs)   = 1 + (length xs)

rank    xs = fold (xs)

isEmpty [] = True
        _  = False
isSingle [_] = True
         _   = False

nth
map
; apply
foldl
foldr
(++)

insert
substr
subseq
drop
take
remove
retain

reverse
sort
search
shuffle
permute
partition

some
every
none






now

read
eval
prInt
error


repl
require
load
version
quit




infix
    right+ 12 (.)
    left   10 (^^)
    left   10 (^)
    left   9  (%)
    left   9  (%%)
    left   9  (/)
    left   9  (*)
    left   8  (-)
    left   8  (+)
    left   8  (++)
    left   6  (<)
    left   6  (<=)
    left   6  (>=)
    left   6  (>)
    left   6  (/=)
    left   6  (==)
    left+  5  [,]
    left+  5  {,}
    left+  5  (,)
    left   4  (|)
    left   4  (&)
    right  3  (->)
    right  2  (&&)
    right  1  (||)
    left   0  ($!)
    right  0  ($)






