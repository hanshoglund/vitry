
-- ======================================================================
-- Basic interpreter tests              
-- ======================================================================

1
1.2
1.
1e12
"test"
"test\ttest"
nil
false
true    

if true 1 0
if true 1 else 0
if false 10
if nil 1 0            
        
let [foo  = `foo]  foo
let [true = false] true
let [true = false] `true

-- Function creation and application
fn (x) x
(fn (x) x) 3
                                    
-- Partial application
(add 1) 2
((fn [x y] add x y) 1) 2
(fn [a b c d e f g h i j k l m n o] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
(fn [a b c d e f g h i j k l m n o p] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
(fn [a b c d e f g h i j k l m n o p] p) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16    
(fn [a b c d e f g h i j k l m n o p q] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17                                                                                
(fn [a b c d e f g h i j k l m n o p q r] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18

((fn [a b c] 0) 1 2 3)

((fn [a b c d e] e) 1 2 3 4 5)
((((((fn [a b c d e] e) 1) 2) 3) 4) 5)

(fn [a b c d e f] f) 1 2 3 4 5 6
(((((((fn [a b c d e f] f) 1) 2) 3) 4) 5) 6)
((((((((((((((((fn [a b c d e f g h i j k l m n o p] p) 1) 2) 3) 4) 5) 6) 7) 8) 9) 10) 11) 12) 13) 14) 15) 16


let [add5 = (add 5)  add26 = (add 26)  mod5 = (mod 5)  x = 0] (eq (mod5 (add26 x)) (add5 x)) 
let [s = (fn [x y z] x z (y z))  k = const   i = id] s k k 3
                 

-- Left-side invocation

let [(cons a b) = (cons 1 2)] a
let [(cons a (cons b c)) = (cons 1 (cons 2 3))] a


-- Operators 
-- Matching
-- Typing
-- Loop and recur



-- Modules
-- Infix decl
-- Type decl
-- Implicits

