<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Vitry Manual</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="author" content="© Hans Höglund 2010" />
    <meta name="date" content="" />


    <link rel="stylesheet" href="styles.css" type="text/css" />
    <script src="jquery.js" type="text/javascript"></script>
    <script src="manual.js" type="text/javascript"></script>
  </head>
  
  <body>
   
    <div id="top-menu">
      <table>
        <tbody>
          <tr class="odd">
            <td align="left">
              <a id="toc-toggle" href="javascript:toggle()">Table of contents</a>
            </td>
            <td align="left">
              <a href="http://github.com/hanshoglund/Vitry">GitHub page</a>
        	  </td>
            <td align="left">
              <a id="toc-toggle" href="">Mailing list</a>
            </td>
            <td align="left">
              <a id="toc-toggle" href="">PDF version</a>
            </td>
          </tr>
        </tbody>
      </table>
    </div><!-- top-menu -->


    <div id="TOC"
    ><ul
      ><li
        ><a href="#introduction"
          >Introduction</a
          ></li
        ><li
        ><a href="#the-language"
          >The language</a
          ><ul
          ><li
    	><a href="#lexical-conventions"
    	  >Lexical conventions</a
    	  ></li
    	><li
    	><a href="#values"
    	  >Values</a
    	  ></li
    	><li
    	><a href="#types"
    	  >Types</a
    	  ><ul
    	  ><li
    	    ><a href="#booleans"
    	      >Booleans</a
    	      ></li
    	    ><li
    	    ><a href="#numbers"
    	      >Numbers</a
    	      ></li
    	    ><li
    	    ><a href="#strings"
    	      >Strings</a
    	      ></li
    	    ><li
    	    ><a href="#symbols"
    	      >Symbols</a
    	      ></li
    	    ><li
    	    ><a href="#or-types"
    	      >Or types</a
    	      ></li
    	    ><li
    	    ><a href="#and-types"
    	      >And types</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#expressions"
    	  >Expressions</a
    	  ><ul
    	  ><li
    	    ><a href="#literal-expressions"
    	      >Literal expressions</a
    	      ></li
    	    ><li
    	    ><a href="#application"
    	      >Application</a
    	      ></li
    	    ><li
    	    ><a href="#infix-expressions"
    	      >Infix expressions</a
    	      ></li
    	    ><li
    	    ><a href="#special-forms"
    	      >Special forms</a
    	      ></li
    	    ><li
    	    ><a href="#delimiters"
    	      >Delimiters</a
    	      ></li
    	    ><li
    	    ><a href="#indentation"
    	      >Indentation</a
    	      ></li
    	    ><li
    	    ><a href="#comments"
    	      >Comments</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#functions"
    	  >Functions</a
    	  ></li
    	><li
    	><a href="#bindings"
    	  >Bindings</a
    	  ><ul
    	  ><li
    	    ><a href="#let-and-where"
    	      >Let and where</a
    	      ></li
    	    ><li
    	    ><a href="#loop-and-recur"
    	      >Loop and recur</a
    	      ></li
    	    ><li
    	    ><a href="#do"
    	      >Do</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#conditions"
    	  >Conditions</a
    	  ><ul
    	  ><li
    	    ><a href="#if"
    	      >If</a
    	      ></li
    	    ><li
    	    ><a href="#match"
    	      >Match</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#modules"
    	  >Modules</a
    	  ><ul
    	  ><li
    	    ><a href="#import"
    	      >Import</a
    	      ></li
    	    ><li
    	    ><a href="#function-syntax"
    	      >Function syntax</a
    	      ></li
    	    ><li
    	    ><a href="#type-syntax"
    	      >Type syntax</a
    	      ></li
    	    ><li
    	    ><a href="#implicits"
    	      >Implicits</a
    	      ></li
    	    ></ul
    	  ></li
    	></ul
          ></li
        ><li
        ><a href="#musical-representation"
          >Musical representation</a
          ><ul
          ><li
    	><a href="#time"
    	  >Time</a
    	  ><ul
    	  ><li
    	    ><a href="#time-scale"
    	      >Time scale</a
    	      ></li
    	    ><li
    	    ><a href="#positions-and-durations"
    	      >Positions and durations</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#pitch"
    	  >Pitch</a
    	  ><ul
    	  ><li
    	    ><a href="#scales"
    	      >Scales</a
    	      ></li
    	    ><li
    	    ><a href="#tuning"
    	      >Tuning</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#events"
    	  >Events</a
    	  ><ul
    	  ><li
    	    ><a href="#notes"
    	      >Notes</a
    	      ></li
    	    ><li
    	    ><a href="#rests"
    	      >Rests</a
    	      ></li
    	    ><li
    	    ><a href="#phrasing"
    	      >Phrasing</a
    	      ></li
    	    ><li
    	    ><a href="#tags"
    	      >Tags</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#processes"
    	  >Processes</a
    	  ><ul
    	  ><li
    	    ><a href="#dynamics"
    	      >Dynamics</a
    	      ></li
    	    ><li
    	    ><a href="#glissandi"
    	      >Glissandi</a
    	      ></li
    	    ><li
    	    ><a href="#tremolo-and-iterations"
    	      >Tremolo and iterations</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#instrumentation"
    	  >Instrumentation</a
    	  ><ul
    	  ><li
    	    ><a href="#performers"
    	      >Performers</a
    	      ></li
    	    ><li
    	    ><a href="#choirs"
    	      >Choirs</a
    	      ></li
    	    ><li
    	    ><a href="#ensembles"
    	      >Ensembles</a
    	      ></li
    	    ><li
    	    ><a href="#standard-setups"
    	      >Standard setups</a
    	      ></li
    	    ><li
    	    ><a href="#arrangements"
    	      >Arrangements</a
    	      ></li
    	    ><li
    	    ><a href="#reductions"
    	      >Reductions</a
    	      ></li
    	    ></ul
    	  ></li
    	><li
    	><a href="#spacialization"
    	  >Spacialization</a
    	  ></li
    	><li
    	><a href="#nonlinearity"
    	  >Nonlinearity</a
    	  ></li
    	><li
    	><a href="#indeterminate-structures"
    	  >Indeterminate structures</a
    	  ></li
    	></ul
          ></li
        ><li
        ><a href="#practical-topics"
          >Practical topics</a
          ><ul
          ><li
    	><a href="#building-and-installing"
    	  >Building and installing</a
    	  ></li
    	><li
    	><a href="#the-interpreter"
    	  >The interpreter</a
    	  ></li
    	><li
    	><a href="#scripts-and-compilation"
    	  >Scripts and compilation</a
    	  ></li
    	><li
    	><a href="#setting-up-the-environment"
    	  >Setting up the environment</a
    	  ></li
    	><li
    	><a href="#calling-foreign-languages"
    	  >Calling foreign languages</a
    	  ></li
    	><li
    	><a href="#replacing-the-syntax"
    	  >Replacing the syntax</a
    	  ></li
    	><li
    	><a href="#real-time"
    	  >Real-time</a
    	  ></li
    	><li
    	><a href="#networking"
    	  >Networking</a
    	  ></li
    	></ul
          ></li
        ><li
        ><a href="#reference"
          >Reference</a
          ><ul
          ><li
    	><a href="#syntax"
    	  >Syntax</a
    	  ></li
    	></ul
          ></li
        ></ul
      ></div
    >
    <!-- TOC -->


    <div id="content">  
      <h1 class="title">Vitry Manual</h1>

      <p>© Hans Höglund 2010</p>
  

<!-- Indent 0 for <pre> -->
<h1 id="introduction"
><a href="#TOC"
  >Introduction</a
  ></h1
><p
>Vitry is a programming language and an environment for representation and manipulation of music. The language features a succinct, expressive syntax and a powerful type system. The represented music can be output in a variety of formats, transcribed to musical notation or used as control data for sound synthesis.</p
><p
>The representation of music is abstract in the sense that it is not concerned with actual sound, but the formal structure of music. The basic idea is to give the user the tools needed to impliment any kind of musical model, while also providing implementations of standard notions of time, pitch, phrasing etc.</p
><p
>Vitry may be used for composition, arranging, transcription or analysis. It is built for easy integration with other environments, particularly the following:</p
><ul
><li
  >Lilypond</li
  ><li
  >Sibelius</li
  ><li
  >SuperCollider</li
  ></ul
><h1 id="the-language"
><a href="#TOC"
  >The language</a
  ></h1
><p
>Vitry is a functional programming language. Well known languages in this family include Lips and Haskell. Like these languages, it depends on functions, values and types are the principal units of abstraction. Mutable state is avoided and recursion and looping are used interchangebly.</p
><p
>Unlike most languages, Vitry treats both functions and types as first class values, that may be referenced and passed to functions like any other.</p
><p
>Vitry strikes a balance between the eager, dynamic nature of the Lisp family and the declarative style of Haskell. Evaluation is strict by default, but non-strict evaluation is possible and lists are non-strict by default. In addition, the type system is based around the notions of implicit conversions, which may be specified in user code.</p
><h2 id="lexical-conventions"
><a href="#TOC"
  >Lexical conventions</a
  ></h2
><p
>The lexical conventions are very simple. All code is parsed into one of the following kinds of tokens by the lexer:</p
><ul
><li
  >Spaces (including tabs and Unicode space characters)</li
  ><li
  >Line breaks</li
  ><li
  >Operators and delimiters</li
  ><li
  >Literals for symbols, strings and numbers</li
  ><li
  >Keywords (for special forms)</li
  ></ul
><p
>Indentation levels are <em
  >expanded</em
  > to delimiters before interpretation, allowing nested expressions to be written without a large amount of parentheses. Thus indentation may be ommited altogether in generated code. For details on the lexical sytax, see the final chapter of this manual.</p
><h2 id="values"
><a href="#TOC"
  >Values</a
  ></h2
><p
>TODO explain structural equivalence</p
><h2 id="types"
><a href="#TOC"
  >Types</a
  ></h2
><p
>TODO (determine) explain type equivalence</p
><h3 id="booleans"
><a href="#TOC"
  >Booleans</a
  ></h3
><p
>The boolean type is written as <code
  >bool</code
  >. Its values are written as <code
  >true</code
  > and <code
  >false</code
  >.</p
><h3 id="numbers"
><a href="#TOC"
  >Numbers</a
  ></h3
><p
>Vitry supports bignum natural, integer and rational numbers, as well as floating-point real and complex numbers. The types of these are written as <code
  >nat</code
  >, <code
  >int</code
  >, <code
  >rat</code
  >, <code
  >float</code
  > and <code
  >complex</code
  > respectively.</p
><p
>Natural, integers and rational numbers are written as sequences of digits. Vitry will automatically convert integers to rationals and vice versa:</p
><pre
><code
  >152
42
-8
3/2
</code
  ></pre
><p
>Floating point numbers may be written in several ways:</p
><pre
><code
  >0.1
0.12e10
2e-5
0.5/2
</code
  ></pre
><p
>We create a complex number by adding the suffix <code
  >i</code
  > to the imaginary part:</p
><pre
><code
  >2i
10 + 1i
22.4 + 32e4i
</code
  ></pre
><p
>Note that to get one imaginary unit you have to write <code
  >1i</code
  >, as <code
  >i</code
  > is not a number literal. Complex numbers in polar form may be entered using the <code
  >cis</code
  > function:</p
><pre
><code
  >22 * cis 4
</code
  ></pre
><h3 id="strings"
><a href="#TOC"
  >Strings</a
  ></h3
><p
>Strings are lists of Unicode characters. The string type is written as <code
  >string</code
  >. String values are written inside double-quotes:</p
><pre
><code
  >&quot;&quot;
&quot;test&quot;
&quot;\&quot;&quot;
&quot;\\&quot;
&quot;I hate music&quot;
</code
  ></pre
><h3 id="symbols"
><a href="#TOC"
  >Symbols</a
  ></h3
><p
>Symbols are representations of unique values. As values equivalence is</p
><p
>All the types described in this manual are in fact type values bound to symbols such as <code
  >bool</code
  >, <code
  >int</code
  >, <code
  >nat</code
  > etc.</p
><p
>The quote character may be used to access operators and delimiters as symbols. This is used to assign functions to operators and delimiters:</p
><pre
><code
  >`++ = concat
`[] = list
`{} = set
</code
  ></pre
><h3 id="or-types"
><a href="#TOC"
  >Or types</a
  ></h3
><p
>TODO</p
><p
>Intersection types capture the notion of <em
  >inheritance</em
  > in object-oriented languages.</p
><h3 id="and-types"
><a href="#TOC"
  >And types</a
  ></h3
><p
>TODO</p
><p
>Intersection types capture the notion of <em
  >composition</em
  > in object-oriented languages.</p
><h2 id="expressions"
><a href="#TOC"
  >Expressions</a
  ></h2
><p
>Expressions are series of tokens generated by the lexer. Each expression produce a single value. We use the characters <code
  >=&gt;</code
  > to indicate evaluation:</p
><pre
><code
  >1            =&gt; 1
2 + 3        =&gt; 5
(2 + 3) * 2  =&gt; 10
not true     =&gt; false
sin (pi/2)   =&gt; 1
</code
  ></pre
><p
>There are five basic forms of expressions, namely literal, applicative, infix and special form. Along with the delimiters, these make up the syntax of the language. A formal specification of the syntax is given in the final chapter.</p
><h3 id="literal-expressions"
><a href="#TOC"
  >Literal expressions</a
  ></h3
><p
>The kind of expression, literals are written representation of simple values:</p
><pre
><code
  >1
22.5
guillaume
&quot;thomas&quot;
</code
  ></pre
><p
>The <code
  >read</code
  > and <code
  >show</code
  > functions may be used to transform such values into their written representation and vice versa. The show function is used by the interpreter to display values.</p
><pre
><code
  >read &quot;22.3&quot;        =&gt; 22.3
read &quot;josquin&quot;     =&gt; josquin
read &quot;\&quot;josquin\&quot;&quot; =&gt; &quot;josquin&quot;

show josquin       =&gt; &quot;josquin&quot;
show &quot;josquin&quot;     =&gt; &quot;josquin&quot;
</code
  ></pre
><h3 id="application"
><a href="#TOC"
  >Application</a
  ></h3
><p
>This form consists of an expression followed by one or more other expressions. The first expression is assumed to be a function, while the others are assumed to be its arguments.<sup
  ><a href="#fn1" class="footnoteRef" id="fnref1"
    >1</a
    ></sup
  ></p
><pre
><code
  >print &quot;hello world&quot;
not true
sum 1 2 3 4
</code
  ></pre
><h3 id="infix-expressions"
><a href="#TOC"
  >Infix expressions</a
  ></h3
><p
>Consists of other expressions, separated by operators. A familiar form is the arithmetic expressions. Examples are:</p
><pre
><code
  >1 + 2
23 % 11
1, 2, 3
-1
~true
true | false
</code
  ></pre
><p
>Operators are made up of distinguished operator characters. Prefix and infix operators are allowed, but not postfix. The following operators are reserved for definitions, type restrictions and quotation respectively:</p
><pre
><code
  >= : `                 
</code
  ></pre
><h3 id="special-forms"
><a href="#TOC"
  >Special forms</a
  ></h3
><p
>Special forms are identified special keywords, which are reserved for a particular use in the language. These are:</p
><ul
><li
  ><code
    >let</code
    > and <code
    >where</code
    > for binding variables.</li
  ><li
  ><code
    >loop</code
    > and <code
    >recur</code
    > for traversal.</li
  ><li
  ><code
    >fn</code
    > for function definitions.</li
  ><li
  ><code
    >if</code
    > and <code
    >match</code
    > for conditional evaluation.</li
  ><li
  ><code
    >do</code
    > for carrying out side-effects like input and output.</li
  ><li
  ><code
    >in</code
    > and <code
    >imply</code
    > for module declarations</li
  ><li
  ><code
    >type</code
    > for type expressions.</li
  ></ul
><h3 id="delimiters"
><a href="#TOC"
  >Delimiters</a
  ></h3
><p
>Delimiters consist of the characters <code
  >()[]{}</code
  >, and may be used to group expressions. Delimiters and must be written to balance. Thus the following expressions are all valid.</p
><pre
><code
  >(1)
(1, 2)
[(1 + 2)]
{(1 + 2) * 3}
</code
  ></pre
><p
>However, the following expression is not:</p
><pre
><code
  >([1)]
</code
  ></pre
><p
>Delimiters are used to indicate precedence:</p
><pre
><code
  >2 * 3 + 4   =&gt; 10
2 * (3 + 4) =&gt; 14
</code
  ></pre
><p
>Delimiters may also be bound to functions, to which the enclosed expression will be applied. Thus look exactly like operator binding:</p
><pre
><code
  >`() = fn x:nat x
`[] = fn x:nat x + 1
`{} = fn x:nat x * 2
</code
  ></pre
><p
>By default, standard parentheses <code
  >()</code
  > are bound to the <code
  >id</code
  > function (so they do nothing).</p
><p
>Brackets and braces are bound to the functions <code
  >list</code
  > and <code
  >set</code
  > respectively. Thus, these delimiters may be thought of as literals for lists and sets, a fact which is acknowledged by the <code
  >show</code
  > method.</p
><pre
><code
  >[1, 2, 3] : list
  =&gt; true

{1, 2, 3} : set
  =&gt; true

repeat 0 2
  =&gt; [0, 0]
</code
  ></pre
><h3 id="indentation"
><a href="#TOC"
  >Indentation</a
  ></h3
><p
>Vitry use indentation as a way of expressing nested expressions without actually having to write out all the delimiters. This is achieved by a process called indentation rewriting, which is performed on all code before interpretation.</p
><p
>TODO</p
><pre
><code
  >john paul
george ringo
=&gt; (john paul) (george ringo)

john paul
  george ringo
=&gt; (john paul (george ringo))

john 
  paul
    george ringo
=&gt; (john (paul (george ringo)))

john 
  paul
  george
    ringo
=&gt; (john (paul) (george (ringo))) 

john 
  paul
    george
  ringo
=&gt; (john (paul (george)) (ringo)) 
</code
  ></pre
><h3 id="comments"
><a href="#TOC"
  >Comments</a
  ></h3
><p
>TODO</p
><h2 id="functions"
><a href="#TOC"
  >Functions</a
  ></h2
><p
>Functions are defined by the <code
  >fn</code
  > special form:</p
><pre
><code
  >fn expr
fn parameter : type expr
fn parameter : type parameter : type ... expr
</code
  ></pre
><p
>TODO</p
><p
>At the semantic level, Vitry makes no distinction between functions, delimiters and operators.</p
><h2 id="bindings"
><a href="#TOC"
  >Bindings</a
  ></h2
><p
>Bindings is the notion of assigning references (values) to symbols. There are three kinds of bindings: global, parametric and local.</p
><p
>Global bindings are typically used to define functions and types and can be accessed from any other expression. Despite the name, they are typically encapsulated into modules. Global bindings can be used declarative (i.e. without any need to concern oneself about evaluation order):</p
><pre
><code
  >b = a + 2
a = 2                                                                               

c = d
d = c    
type c, d
</code
  ></pre
><p
>Parametric binding is the process of substituting a the parameters of a function with the given arguments upon evaluation. Local bindings are &quot;one-off&quot; associations that apply to a single expression. The only difference between local and parametric binding except that local binding is performed directly upon evaluation of the given expression. Both are resolved though lexical scoping, thus inner bindings always override outer:</p
><pre
><code
  >let foo = 1
  let foo = 2
    foo
=&gt; 2

(fn [foo bar] 
  fn [foo bar] 
    bar foo
  bar foo) 1 2 
=&gt; 1 2 
</code
  ></pre
><h3 id="let-and-where"
><a href="#TOC"
  >Let and where</a
  ></h3
><p
>The <code
  >let</code
  > or <code
  >where</code
  > forms provide local binding. They are identical except that the let form expects the bound expression first, and the where form last. Bound expression evaluates to the value of the scoped expression with the given values bound in.</p
><pre
><code
  >let atom = expr expr
let atom = expr atom = expr ... expr

expr where atom = expr
expr where atom = expr atom = expr ...
</code
  ></pre
><p
>Example :</p
><pre
><code
  >let foo = 1
    bar = 2   
  foo + bar
=&gt; 3

foo + bar where
  foo = 1
  bar = 2   
=&gt; 3
</code
  ></pre
><p
>The <code
  >let</code
  > and <code
  >where</code
  > forms are very useful for creating local variables or factoring out expressions to make them more readable.</p
><h3 id="loop-and-recur"
><a href="#TOC"
  >Loop and recur</a
  ></h3
><p
>The <code
  >loop</code
  > and <code
  >recur</code
  > forms (borrowed from <a href="http://clojure.org/"
  >Clojure</a
  >) are the most efficient way to traverse data structures.</p
><p
>TODO</p
><pre
><code
  >loop atom = expr expr
loop atom = expr atom = expr ... expr

recur expr
recur expr expr ...
</code
  ></pre
><h3 id="do"
><a href="#TOC"
  >Do</a
  ></h3
><p
>TODO</p
><h2 id="conditions"
><a href="#TOC"
  >Conditions</a
  ></h2
><h3 id="if"
><a href="#TOC"
  >If</a
  ></h3
><h3 id="match"
><a href="#TOC"
  >Match</a
  ></h3
><h2 id="modules"
><a href="#TOC"
  >Modules</a
  ></h2
><h3 id="import"
><a href="#TOC"
  >Import</a
  ></h3
><h3 id="function-syntax"
><a href="#TOC"
  >Function syntax</a
  ></h3
><h3 id="type-syntax"
><a href="#TOC"
  >Type syntax</a
  ></h3
><h3 id="implicits"
><a href="#TOC"
  >Implicits</a
  ></h3
><h1 id="musical-representation"
><a href="#TOC"
  >Musical representation</a
  ></h1
><p
>Vitry provides a large set of types and functions that simplifies the manipulation of musical data. These are defined in the language itself, giving the user of the power to define structures that operate on exactly the same level of abstraction as the built-in structures.</p
><p
>TODO music vs notation</p
><h2 id="time"
><a href="#TOC"
  >Time</a
  ></h2
><p
>Musical time <sup
  ><a href="#fn2" class="footnoteRef" id="fnref2"
    >2</a
    ></sup
  > can be represented in numerous ways. We use a type <code
  >time</code
  > as a general representation of linear and synchronous time. By <em
  >linear</em
  > we mean that <code
  >time</code
  > progresses consistently without repetition or jumps, and by <em
  >synchronous</em
  > that relations between <code
  >time</code
  > values can be taken to hold in all cases. This will be sufficient to represent most conventional music. Nonlinear and nonsynchronous time will be covered in later sections.</p
><h3 id="time-scale"
><a href="#TOC"
  >Time scale</a
  ></h3
><p
>TODO absolute and relative (time)</p
><h3 id="positions-and-durations"
><a href="#TOC"
  >Positions and durations</a
  ></h3
><p
>Time values are commonly used to represent <em
  >positions</em
  > in a bar-beat grid, as well as <em
  >durations</em
  >, meaning the difference between the onset and offset position of a certain event. There is no real need to make this distinction on the type level, but we will introduce two handy synonyms for <code
  >time</code
  > that can be used to prevent mix-ups when working larger time structures.</p
><p
>TODO make distinction between abs/rel <em
  >time scale</em
  > as above and abs/rel <em
  >durations</em
  > as in MIDI</p
><pre
><code
  >type 
  time         = absoluteTime | relativeTime
  absoluteTime = sec
  relativeTime = rat
  pos          = time
  dur          = time
  sec          = float
</code
  ></pre
><p
>TODO tuples</p
><p
>TODO scaling tempo</p
><p
>TODO continous tempo scaling</p
><p
>TODO quantization</p
><p
>Relative time is simply represented as rational numbers, using the conventional note names as reference point. Thus the values <code
  >1, 1/2, 1/4, 1/4</code
  > may be read as whole note, half note, quarter note, quarter note.</p
><p
>For absolute time we use standardized units:</p
><pre
><code
  >implicit type
  min  = 60 * sec
  hour = 60 * min
  day  = 24 * hour
  Hz   = 1 / sec
  kHz  = hz * 10e3
  MHz  = hz * 10e6
</code
  ></pre
><p
>TODO</p
><h2 id="pitch"
><a href="#TOC"
  >Pitch</a
  ></h2
><p
>Pitch is readily represented as an absolute frequency value or as a postion in a scale.</p
><h3 id="scales"
><a href="#TOC"
  >Scales</a
  ></h3
><p
>TODO tuning systems</p
><h3 id="tuning"
><a href="#TOC"
  >Tuning</a
  ></h3
><p
>TODO reference frequency</p
><p
>TODO</p
><h2 id="events"
><a href="#TOC"
  >Events</a
  ></h2
><p
>Events is the abstract type representing discrete musical actions. TODO</p
><h3 id="notes"
><a href="#TOC"
  >Notes</a
  ></h3
><p
>TODO</p
><h3 id="rests"
><a href="#TOC"
  >Rests</a
  ></h3
><p
>TODO</p
><h3 id="phrasing"
><a href="#TOC"
  >Phrasing</a
  ></h3
><p
>TODO</p
><h3 id="tags"
><a href="#TOC"
  >Tags</a
  ></h3
><p
>TODO</p
><h2 id="processes"
><a href="#TOC"
  >Processes</a
  ></h2
><p
>A musical process (not to be confused with a computational) is the abstract type representing continuous musical actions.</p
><p
>TODO</p
><h3 id="dynamics"
><a href="#TOC"
  >Dynamics</a
  ></h3
><p
>TODO</p
><h3 id="glissandi"
><a href="#TOC"
  >Glissandi</a
  ></h3
><p
>TODO</p
><h3 id="tremolo-and-iterations"
><a href="#TOC"
  >Tremolo and iterations</a
  ></h3
><p
>TODO</p
><h2 id="instrumentation"
><a href="#TOC"
  >Instrumentation</a
  ></h2
><p
>The concept of instrumentation may be generalized to represent the distribution of a set of events across a set of <em
  >performers</em
  > or <em
  >ensembles</em
  >. This concept is useful not only for orchestral music, but also for distribution of events across synthesizers, or even virtual performers such as sub-processes of a generative piece.</p
><p
>The atomic unit of instrumentation is the performer, defined as a receiver of musical events. There is no theoretical distinction between a vocal, instrumental or virtual performer, but we provide these synonyms for convenience.</p
><pre
><code
  >type 
  performer
  singer      = performer
  instrument  = performer
</code
  ></pre
><h3 id="performers"
><a href="#TOC"
  >Performers</a
  ></h3
><h3 id="choirs"
><a href="#TOC"
  >Choirs</a
  ></h3
><h3 id="ensembles"
><a href="#TOC"
  >Ensembles</a
  ></h3
><h3 id="standard-setups"
><a href="#TOC"
  >Standard setups</a
  ></h3
><h3 id="arrangements"
><a href="#TOC"
  >Arrangements</a
  ></h3
><h3 id="reductions"
><a href="#TOC"
  >Reductions</a
  ></h3
><p
>TODO</p
><h2 id="spacialization"
><a href="#TOC"
  >Spacialization</a
  ></h2
><p
>As instrumentation is concerned with distribution of events amongst discrete groups or individuals, we may also consider the distribution of events or processes in a spacial continuum.</p
><p
>Spacialization is generally mostly of interest in acousmatic music, as fine control of the spacial parameter is not available in the instrumental or vocal genres. However, if spacialization is treated a continous distribution in an abstract sense, there are possibilities of using &quot;virtual spaces&quot; to control other musical parameters. It may also be used in conjunction with instrumentation to model the real-life spacial setup of an ensemble.</p
><p
>TODO</p
><h2 id="nonlinearity"
><a href="#TOC"
  >Nonlinearity</a
  ></h2
><p
>called <code
  >nonlinear</code
  > and <code
  >nonsync</code
  > TODO</p
><h2 id="indeterminate-structures"
><a href="#TOC"
  >Indeterminate structures</a
  ></h2
><p
>TODO</p
><h1 id="practical-topics"
><a href="#TOC"
  >Practical topics</a
  ></h1
><h2 id="building-and-installing"
><a href="#TOC"
  >Building and installing</a
  ></h2
><p
>Vitry targets the <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine"
  >Java Virtual Machine</a
  >, and may be used with almost any operating system. The only dependency is the Java runtime environment. The build requirements are <a href="http://git-scm.com/"
  >Git</a
  > and <a href="http://ant.apache.org/"
  >Apache Ant</a
  >. You may check if these are installed as follows:</p
><pre
><code
  >$ java
$ git
$ ant
</code
  ></pre
><p
>If not, download and install from the sites above or through your package management system.</p
><p
>As soon as the build requirements are in place, do:</p
><pre
><code
  >$ git clone git@github.com:hanshoglund/vitry.git
$ cd vitry
$ ant
$ sudo ant install
</code
  ></pre
><p
>Or if you are on Windows:</p
><pre
><code
  >$ git clone git@github.com:hanshoglund/vitry.git
$ cd vitry
$ ant
$ ant install
</code
  ></pre
><p
>You may append a directory to the install command.</p
><h2 id="the-interpreter"
><a href="#TOC"
  >The interpreter</a
  ></h2
><p
>The interpreter is typically the simplest way to interact with Vitry. To run it, simply type <code
  >vitry</code
  >.</p
><p
>TODO</p
><p
>The interpreter also accepts special commands commenced by a colon. These are not part of the Vitry language, but exist for ease of use in the interpreter.</p
><h2 id="scripts-and-compilation"
><a href="#TOC"
  >Scripts and compilation</a
  ></h2
><p
>While the interpreter provides a simple way to experiment and test out code, larger projects will require writing code in files. Vitry accepts text files or precompiled class files for execution. The only difference between the two is that class files may execute somewhat faster.</p
><p
>Vitry code is written in standard text files. Only the UTF-8 encoding is accepted. File names typically have the <code
  >.vitry</code
  > suffix, allthough this is not required. There is no difference between the kind of expressions allowed in the interpreter and in file source code except that the interpreter commands are not allowed in files. Vitry files may have a shebang line, allowing them to be executed in standard Unix shells.</p
><p
>In a large Vitry project, most source code files will be used to define modules and implicits. To make an executable program a module containin a main function is required.</p
><pre
><code
  >in myApp
  main = do
    prompt &quot;Please enter your name:&quot;
    post + (&quot;Hello &quot; ++ _)
</code
  ></pre
><p
>To excute a script, simply use:</p
><pre
><code
  >$ vitry hello.vitry
</code
  ></pre
><h2 id="setting-up-the-environment"
><a href="#TOC"
  >Setting up the environment</a
  ></h2
><p
>TODO</p
><h2 id="calling-foreign-languages"
><a href="#TOC"
  >Calling foreign languages</a
  ></h2
><p
>TODO</p
><h2 id="replacing-the-syntax"
><a href="#TOC"
  >Replacing the syntax</a
  ></h2
><p
>TODO</p
><h2 id="real-time"
><a href="#TOC"
  >Real-time</a
  ></h2
><p
>TODO</p
><h2 id="networking"
><a href="#TOC"
  >Networking</a
  ></h2
><p
>TODO</p
><h1 id="reference"
><a href="#TOC"
  >Reference</a
  ></h1
><h2 id="syntax"
><a href="#TOC"
  >Syntax</a
  ></h2
><pre
><code
  >expr 
  : '(' inline ')'
  | '[' inline ']'
  | '{' inline '}'

  | 'fn' parameter* expr
  | 'let' binding* expr
  | 'do' '(' expr+ ')'
  | 'if' expr expr 'else'? expr

  | atom
  | natural
  | float
  | complex
  | string

parameter 
  : atom ':' expr
binding   
  : atom '=' expr

inline
    : apply (operator+ apply)+
    | apply
    | empty

apply
    : expr+
    | expr

empty
    :

operator
  Any of the following characters in any order
  ! # $ % &amp; \ * + , - . / ; &lt; = &gt; ? @ \ ^ _ ` | ~ '

atom
  a-z or A-Z followed by any number of a-z, A-Z or 0-9

natural
  any number of 0-9

float
  TODO

complex
  TODO

string
  TODO
</code
  ></pre
><div class="footnotes"
><hr
   /><ol
  ><li id="fn1"
    ><p
      >As in Haskell, functions may always partially applied. Thus function application may be seen as a left-associative binary operation, which is true to the original concept of the lambda calculus. <a href="#fnref1" class="footnoteBackLink" title="Jump back to footnote 1">↩</a></p
      ></li
    ><li id="fn2"
    ><p
      >Here taken to mean a measurable unit of time (as in the sentence &quot;one second's time&quot;), not the amount of beats in a musical pulsation. <a href="#fnref2" class="footnoteBackLink" title="Jump back to footnote 2">↩</a></p
      ></li
    ></ol
  ></div
>
    </div><!-- content -->

  </body>
  
</html>
