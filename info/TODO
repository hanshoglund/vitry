                                    
                 
                 
                 
Old stuff                 
Should be moved to tracker


****




- Implement a core language
    - Type system                   
    - Lexer/Parser, Interpreter, Compiler, Runtime  


    
- Type system
    - General strategy:
        - Patterns are first-class, types are not
        - A type encapsulates a pattern, values must be tagged explicitly
            - In the future we may use this to provide non-dynamic versions of Apply,
              including primitive forms
        - Declared types, (declared or inferred) function types, and declared implicits are checked at compile time
        - Dependent types and invariants are checked at runtime                             
            - This may be replaced by a staged compilation strategy

        - Special types to match nat, int etc.
        - We will need some kind of distributive rewriting on Products/FunctionTypes vs. Unions
          for the implementation of method overloading
    
                                        
        - Retagging: OK if the old type includes the new ("narrowing conversion")


- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions (invokevirtual) by default
        - Others may be added for TCO, see Compiler
    - Semantically, all functions are unary and curried       

- Records
    - Straight tuples
    - Unlike Haskell, no special lookup functions, instead we use the type (just as we support untagged unions)
    - Lookup functions simply does the following + memoization
        (match map
          (key,_,_)
          (_,key,_)
          (_,_,key))
    - The record function can tag/retag values to support user-defined "keys"
    - As these tags are equivalent to the actual type of the value, they do not cause any problems when
      the value is used with the original type (see retagging)


====================================================================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Proper tail-call opt
- Kinds (library level)
- Macros/user defined syntax

