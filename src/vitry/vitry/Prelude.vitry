; Vitry, copyright (C) Hans Hoglund 2011
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; See COPYING.txt for details.

module Vitry.Prelude


; internal functions (not part of the prelude definition):
;         rewrite seq array symbol string
;         class new method classOf



; Core types and constructors

; native: nil true false bool empty
;         () [] {} _
;         (,) [,] {,} (|) (&) (->) (<->)



; Functions

; native: arity id const flip (.) (..)

iter f n = match [f, n]
    [f, 0] = id
    [f, i] = f . (iter f (i - 1))

(.')  f g = (fn (x y) f (g x y))
(..') g f = (fn (x y) f (g x y))
first  x y = x
second x y = y



; Booleans

; native (==)

not  x = match x
    _ : true  = false
    _ : false = true

(!=) x y = not (x == y)

(&&) x y = match [x, y]
    [ _ : true, _ : true ] = true
    [ _ : bool, _ : bool ] = false

(||) x y = match [x, y]
    [ _ : true, _ : bool ] = true
    [ _ : bool, _ : true ] = true
    [ _ : bool, _ : bool ] = false



; Number and string types

; native: nat int rat float
;         double complex
;         char str

prec = nat
     | int
     | rat
real = float
     | double
     | complex
num  = prec
     | real



; Enumeration and comparison

; native: (<) (>)

(>=) x y = x > y || x == y
(<=) x y = x < y || x == y

zeroth = 0
succ x = x + 1
pred x = x - 1
compare x y = if (x < y) `smaller else if (x == y) `equal else `larger
largest  x y = if (x > y) x else y
smallest x y = if (x < y) x else y
max xs = foldl largest (head xs) (tail xs)
min xs = foldl smallest (head xs) (tail xs)



; Arithmetic

MATH           = class "Math"
INT            = class "java.math.BigInteger"
ABS            = method MATH "abs" [ `double ]
LONG_TO_INT    = method INT "valueOf" [ `long ]
INT_TO_LONG    = method INT "longValue" []
MATH_PRIM name = method MATH name [ `double ]

; native: (+) (-) (*) (/) (%) (^)
;         NaN Infinity

e  = 2.718281828459045
pi = 3.141592653589793

abs x = match x
    x : prec = if (x < 0) (-x) else x
    x : real = ABS x

negate x = -x

; TODO signum recip
;      gcd lcm
;      approx rationalize


sqrt  =  MATH_PRIM "sqrt"
ln    =  MATH_PRIM "log" 
sin   =  MATH_PRIM "sin" 
tan   =  MATH_PRIM "tan" 
cos   =  MATH_PRIM "cos" 
asin  =  MATH_PRIM "asin"
atan  =  MATH_PRIM "atan"
acos  =  MATH_PRIM "acos"
ceil  =  MATH_PRIM "ceil"
floor =  MATH_PRIM "floor"
round =  MATH_PRIM "round" .. LONG_TO_INT

logn n : real = ln .. (* (1. / ln n))
log           = logn 10.
log2          = logn 2.

isOdd      x : num = x % 2 == 1
isEven     x : num = x % 2 == 0
isZero     x : num = match x (0 = true) (0.0 = true) (_ = false)
isPositive x : num = match x (x : prec = x > 0) (x : real = x > 0.0) 
isNegative x : num = match x (x : prec = x < 0) (x : real = x < 0.0)
isNan      x : num = (x == NaN)
isInfinite x : num = (x == Infinity)
isNumber   x : num = not (isNan x)
isFinite   x : num = not (isInfinite x) && not (isNan x)

sum     = foldl (+) 0
product = foldl (*) 1



; Lists

; TODO Naive implementations
; TODO Assure all work for strings

; native: prepend head tail

append x = (flip (++)) [x]
last     = foldl second [] . tail
init xs  = match xs
    (x, xs : []) = []
    (x, xs)      = prepend x (init xs)


length   = foldr ((+ 1) .' second) 0
rank xs  = match xs
    _ : [] = 1
    _      = (succ . max . (map
                 fn (xs) match xs
                     _  : []    = 1
                     xs : [ _ ] = rank xs
                     _          = 0)) 
              xs 

isEmpty xs  = match xs
    _ : ()    = true
    _ : [ _ ] = false
isSingle xs = match xs
    _ : ()    = false
    _         = (tail xs) == ()

substr m n = take n . drop m



zipWith f xs ys = match [f, xs, ys]
    [ f, (x, xs), (y, ys) ] = prepend (f x y) (zipWith f xs ys)
    [ _, _, _ ]             = ()

zip = zipWith (,)

interleave xs ys = foldr (fn ((x,y) zs) [x] ++ [y] ++ zs) [] (zip xs ys)
intersperse y xs = prepend (head xs) (foldl (fn (zs x) zs ++ [y] ++ [x]) [] (tail xs))


reverse   = foldl (flip prepend) []
; remove
; retain
; sort
; search

find pred = foldl (fn (x y) if (pred y) y else x) ()
; partition

; shuffle
; permute

repeat   = unfold (fn (x) (x, x))
cycle xs = unfold (fn ((orig, (x, xs))) (x, (xs, (if (xs == ()) orig else xs)))) (xs, xs)

some  = foldr (||) false
every = foldr (&&) true
none  = not . some

; str -> [a] -> str
join s = foldr (++) "" . intersperse s . map string



; native: now random
;         parse print parseFile eval error
;         readFile writeFile
;         repl load quit

version = (method (class "VitryRuntime") "getVersion" []) ()
versionStr = join
    intersperse "." (map string version)

sleep time = do time = INT_TO_LONG time
                (method (class "Thread") "sleep" [ `long ]) time
                time
    
timer f    = do start = now ()
                f ()
                now () - start