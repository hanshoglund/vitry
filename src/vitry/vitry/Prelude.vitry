; Vitry, copyright (C) Hans Hoglund 2011
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; See COPYING.txt for details.

module Vitry.Prelude


; internal functions (not part of the prelude definition):
;         rewrite seq array symbol string
;         class new method classOf



; Core types and constructors

; native: nil true false bool empty
;         () [] {} _
;         (,) [,] {,} (|) (&) (->) (<->)



; Functions

; native: arity 
;         id const flip (.)

iter f n = match [f, n]
    [f, 0] = id
    [f, i] = f . (iter f (i - 1))

(.')  f g = fn (x y) f (g x y)

; Church booleans
left  x y = x
right x y = y



; Booleans

; native: (==)

not  x = match x
    _ : true  = false
    _ : false = true

(!=) x y = not (x == y)

(||) x y = match (x, y)
    ( _ : true , _ ) = true
    ( _ , _ : true ) = true
    _                = false

(&&) x y = match (x, y)
    ( _ : true, _ : true ) = true
    _                      = false



; Number and string types

; native: nat int rat float
;         double complex
;         char str

prec = nat
     | int
     | rat
real = float
     | double
     | complex
num  = prec
     | real



; Ordering and enumeration

; native: (<) (>)

(>=) x y = x > y || x == y
(<=) x y = x < y || x == y

zeroth x = match x (x : prec = 0) (x : real = 0.0)
succ x   = match x (x : prec = x + 1) (x : real = x + 1.0)
pred x   = match x (x : prec = x - 1) (x : real = x - 1.0)
order x n = (iter succ n) (zeroth x)
compare  x y = if (x < y) `smaller else if (x == y) `equal else `larger
largest  x y = if (x > y) x else y
smallest x y = if (x < y) x else y
max xs = foldl largest (head xs) (tail xs)
min xs = foldl smallest (head xs) (tail xs)



; Arithmetic

MATH           = class "Math"
NUM            = class "java.lang.Number"
INT            = class "java.math.BigInteger"
RAT            = class "vitry.runtime.BigRational"
ABS            = method MATH "abs" [ `double ]
NUM_TO_LONG    = method NUM "longValue" []
NUM_TO_DOUBLE  = method NUM "doubleValue" []
RAT_TO_INT     = method RAT "bigIntegerValue" []
LONG_TO_INT    = method INT "valueOf" [ `long ]
DOUBLE_TO_RAT  = method RAT "valueOf" [ `double ]
MATH_PRIM name = method MATH name [ `double ]

; native: (+) (-) (*) (/) (%) (^)
;         NaN Infinity

e  = 2.718281828459045
pi = 3.141592653589793

abs x = match x
    x : prec = if (x < 0) (-x) else x
    x : real = ABS x

negate x = -x

; TODO signum recip
;      gcd lcm

sqrt  =  MATH_PRIM "sqrt"
ln    =  MATH_PRIM "log" 
sin   =  MATH_PRIM "sin" 
tan   =  MATH_PRIM "tan" 
cos   =  MATH_PRIM "cos" 
asin  =  MATH_PRIM "asin"
atan  =  MATH_PRIM "atan"
acos  =  MATH_PRIM "acos"
ceil  x : num = match x 
    x : real = (MATH_PRIM "ceil") x
    x : rat = (method RAT "ceil" []) x
    x : int = x
floor x : num = match x
    x : real = (MATH_PRIM "floor") x
    x : rat = (method RAT "floor" []) x 
    x : int = x

round  = LONG_TO_INT . MATH_PRIM "round"
approx = NUM_TO_DOUBLE
rationalize = DOUBLE_TO_RAT

logn n : real = (* (1.0 / ln n)) . ln
log           = logn 10.0
log2          = logn 2.0

isOdd      x : num = x % 2 == 1
isEven     x : num = x % 2 == 0
isZero     x : num = match x (0 = true) (0.0 = true) (_ = false)
isPositive x : num = match x (x : prec = x > 0) (x : real = x > 0.0) 
isNegative x : num = match x (x : prec = x < 0) (x : real = x < 0.0)
isNan      x : num = (x == NaN)
isInfinite x : num = (x == Infinity)
isNumber   x : num = not (isNan x)
isFinite   x : num = not (isInfinite x) && not (isNan x)

sum     = foldr (+) 0
product = foldr (*) 1
mean xs = sum xs / length xs




; Lists

; TODO Assure all work for strings

; native: (++)
;         prepend head tail 
;         init last
;         index

append x = flip (++) [x]
length   = foldr ((+ 1) .' right) 0
rank xs  = match xs
    _ : [] = 1
    _      = (succ . max . (map
                 fn (xs) match xs
                     _  : []    = 1
                     xs : [ _ ] = rank xs
                     _          = 0)) 
              xs 

isEmpty xs = match xs
    _ : ()      = true
    _ : ""      = true
    _           = false
isSingle xs = match xs
    _ : ()      = false
    (x, _ : ()) = true
    _           = false
      



; native: drop take
;         map foldl foldr
;         range sort reverse
;         unfold

substr m n = take n . drop m
; reverse   = foldl (flip prepend) []

; TODO remove
; TODO retain
; TODO search
find pred = foldl (fn (x y) if (pred y) y else x) ()

; partition
; permute

some  = foldr (||) false
every = foldr (&&) true
none  = not . some

; native: unfold

arith d   = unfold (fn (x) (x, x + d))
geom  d   = unfold (fn (x) (x, x * d))
harm      = map (/ 1) (arith 1 1) 
randoms n = map (fn (x) random n) (repeat 1)

repeat        = unfold (fn (x) (x, x))
cycle      xs = xs ++ (delay cycle xs)
palindrome xs = let sx = reverse xs
                    xs ++ sx ++ (delay palindrome xs)



zipWith f xs ys = match [f, xs, ys]
    [ f, (x, xs), (y, ys) ] = prepend (f x y) (zipWith f xs ys)
    [ _, _, _ ]             = ()
                                  

zip3With f xs ys zs = match [f, xs, ys, zs]
    [ f, (x, xs), (y, ys), (z, zs) ] = prepend (f x y z) (zip3With f xs ys zs)
    [ _, _, _, _ ]                   = ()

zipWithL f xs ys = delay 
    prepend 
        f (head xs) (head ys)
        zipWithL f (tail xs) (tail ys)

zip3WithL f xs ys zs = delay
    prepend 
        f (head xs) (head ys) (head zs)
        zip3WithL f (tail xs) (tail ys) (tail zs)


zip = zipWith (,)
zip3 = zip3With (,)
zipL = zipWithL (,)
zip3L = zip3WithL (,)


dup = foldr (fn (x y) [x, x] ++ y) []

dupL xs = delay
    let x = head xs
        [x, x] ++ dupL (tail xs)

; lazy!
interlL xs ys = delay
    let x = head xs
        y = head ys
        [x, y] ++ interlL (tail xs) (tail ys)

interl3L xs ys zs = delay 
    let x = head xs
        y = head ys
        y = head zs
        [x, y, zs] ++ interl3L (tail xs) (tail ys) (tail zs)


interp y xs = prepend (head xs) (foldl (fn (zs x) zs ++ [y] ++ [x]) [] (tail xs))




; str -> [a] -> str
join s = foldr (++) "" . interp s . map string

; Force and buffer n values
buffer n xs = force (take n xs) ++ drop n xs
    
bufferStream n xs = force (take n xs) ++ (delay bufferStream n (drop n xs))




; System

; native: now random
;         parse print parseFile eval error
;         readFile writeFile
;         repl load quit

version    = (method (class "VitryRuntime") "getVersion" []) ()
versionStr = join "." (map string version)

RANDOM        = class "java.util.Random"
RANDOM_INST   = new RANDOM
RAND_FLOAT    = method RANDOM "nextFloat" ()

randomFloat _ = RAND_FLOAT RANDOM_INST
    
pick xs       = index (random (length xs)) xs
decide f g x  = match (random 2) (0 = f x) (1 = g x)
; shuffle


OBJECT           = class "java.lang.Object"
THREAD_LOCAL     = class "java.lang.ThreadLocal"
THREAD_LOCAL_GET = method THREAD_LOCAL "get" []
THREAD_LOCAL_SET = method THREAD_LOCAL "set" [ OBJECT ]

ref _   = new THREAD_LOCAL
get r   = THREAD_LOCAL_GET r
set r x = 
    do THREAD_LOCAL_SET r x
       r

THREAD_SLEEP = method (class "Thread") "sleep" [ `long ]

sleep time = do time = NUM_TO_LONG time
                THREAD_SLEEP time
                time
    
timer f    = do start = now ()
                f ()
                now () - start
