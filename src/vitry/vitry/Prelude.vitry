; Vitry, copyright (C) Hans Hoglund 2011
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; See COPYING.txt for details.

module Vitry.Prelude



; internal functions (not part of the prelude definition):
;         rewrite seq array symbol string
;         class new method classOf



; Core types and constructors

; native: nil true false bool empty
;         () [] {} _
;         (,) [,] {,} (|) (&) (->) (<->)



; Functions

; native: arity id const flip (.) (..)

iter f n = match (f, n)
    (f, 0) = id
    (f, i) = f . (iter f (i - 1))



; Booleans

; native (==)

not  x = match x
    _:true  = false
    _:false = true

(!=) x y = not (x == y)

(&&) x y = match (x, y)
    (_:true, _:true) = true
    (_:bool, _:bool) = false

(||) x y = match (x, y)
    (_:true, _:bool) = true
    (_:bool, _:true) = true
    (_:bool, _:bool) = false



; Number and string types

; native: nat int rat float
;         double complex
;         char str

prec = nat
     | int
     | rat
real = float
     | double
     | complex
num  = prec
     | real



; Enumeration and comparison

; native: (<) (>)

(>=) x y = x > y || x == y
(<=) x y = x < y || x == y

zeroth = 0
succ x = x + 1
pred x = x - 1
largest  x y = if (x > y) x else y
smallest x y = if (x < y) x else y
max xs = foldl largest (head xs) (tail xs)
min xs = foldl smallest (head xs) (tail xs)



; Arithmetic

; native: (+) (-) (*) (/) (%) (^)
;         NaN Infinity

e  = 2.718281828459045
pi = 3.141592653589793

_math   = class "Math"
_bigint = class "java.math.BigInteger"
_abs    = method _math "abs" [ `double ]

abs x = match x
    x:prec = if (x < 0) (-x) else x
    x:real = _abs x

negate x = -x

; TODO signum recip
;      gcd lcm
;      approx rationalize

_mathPrim name = method _math name [ `double ]

sqrt  =  _mathPrim "sqrt"
ln    =  _mathPrim "log" 
sin   =  _mathPrim "sin" 
tan   =  _mathPrim "tan" 
cos   =  _mathPrim "cos" 
asin  =  _mathPrim "asin"
atan  =  _mathPrim "atan"
acos  =  _mathPrim "acos"
ceil  =  _mathPrim "ceil"
floor =  _mathPrim "floor"
round =  _mathPrim "round" .. method _bigint "valueOf" [ `long ]

logn n : real = ln .. (* (1. / ln n))
log           = logn 10.
log2          = logn 2.

isOdd      x : num = x % 2 == 1
isEven     x : num = x % 2 == 0
isZero     x = match x
                   0       = true
                   0.0     = true
                   _ : num = false
isPositive x : num = x > 0
isNegative x : num = x < 0
isNan      x : num = (x == NaN)
isInfinite x : num = (x == Infinity)
isNumber   x : num = not (isNan x)
isFinite   x : num = not (isInfinite x) && not (isNan x)

sum     = foldl (+) 0
product = foldl (*) 1



; Lists

; native eager: prepend head tail
;               foldl foldr nth


; native lazy: unfold (++) map (...) 



; TODO append
last = foldl (fn (x y) y) []
; TODO init (lazy)

length = foldr (+ 1) 0
; TODO rank
isEmpty xs = match xs
    _ : []  = true
    _ : [_] = false
isSingle xs = match xs
    [_]     = true
    _ : [_] = false

; TODO apply

; TODO insert
; TODO substr
; TODO subseq
; TODO drop
; TODO take
; TODO remove
; TODO retain

zipWith f xs ys =
    match (f, xs, ys)
        (f, (x, xs), (y, ys)) = prepend (f x y) (zipWith f xs ys)
        (_, _, _)             = ()

zip = zipWith (,)

interleave xs ys = foldr (fn ((x,y) zs) [x] ++ [y] ++ zs) [] (zip xs ys)
intersperse y xs = prepend (head xs) (foldl (fn (zs x) zs ++ [y] ++ [x]) [] (tail xs))


reverse   = foldl (flip prepend) []
; sort
; search

find pred = foldl (fn (x y) if (pred y) y else x) ()
; filter
; partition

; shuffle
; permute

repeat   = unfoldl (fn (x) (x, x))
cycle xs = unfoldl (fn ((orig, (x, xs))) (x, (xs, (if (xs == ()) orig else xs)))) (xs, xs)

some  = foldr (||) false
every = foldr (&&) true
none  = not . some

join  = foldr (++) ""



; native: now random
;         parse print parseFile eval error
;         readFile writeFile
;         repl load quit

version = (method (class "VitryRuntime") "getVersion" []) ()
versionStr = join
    intersperse "." (map string version)
