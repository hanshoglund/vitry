; Vitry, copyright (C) Hans Hoglund 2011
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; See COPYING.txt for details.

module Vitry.Prelude


; internal functions (not part of the prelude definition):
;         rewrite seq array symbol string
;         class new method classOf



; Core types and constructors

; native: nil true false bool empty
;         () [] {} _
;         (,) [,] {,} (|) (&) (->) (<->)



; Functions

; native: arity id const flip (.) (..)

iter f n = match [f, n]
    [f, 0] = id
    [f, i] = f . (iter f (i - 1))

(.')  f g = (fn (x y) f (g x y))
(..') g f = (fn (x y) f (g x y))
first  x y = x
second x y = y



; Booleans

; native (==)

not  x = match x
    _ : true  = false
    _ : false = true

(!=) x y = not (x == y)

(&&) x y = match [x, y]
    [ _ : true, _ : true ] = true
    [ _ : bool, _ : bool ] = false

(||) x y = match [x, y]
    [ _ : true, _ : bool ] = true
    [ _ : bool, _ : true ] = true
    [ _ : bool, _ : bool ] = false



; Number and string types

; native: nat int rat float
;         double complex
;         char str

prec = nat
     | int
     | rat
real = float
     | double
     | complex
num  = prec
     | real



; Enumeration and comparison

; native: (<) (>)

(>=) x y = x > y || x == y
(<=) x y = x < y || x == y

zeroth = 0
succ x = x + 1
pred x = x - 1
compare x y = if (x < y) `smaller else if (x == y) `equal else `larger
largest  x y = if (x > y) x else y
smallest x y = if (x < y) x else y
max xs = foldl largest (head xs) (tail xs)
min xs = foldl smallest (head xs) (tail xs)



; Arithmetic

MATH           = class "Math"
NUM            = class "java.lang.Number"
INT            = class "java.math.BigInteger"
RAT            = class "vitry.runtime.BigRational"
ABS            = method MATH "abs" [ `double ]
NUM_TO_LONG    = method NUM "longValue" []
NUM_TO_DOUBLE  = method NUM "doubleValue" []
RAT_TO_INT     = method RAT "bigIntegerValue" []
LONG_TO_INT    = method INT "valueOf" [ `long ]
DOUBLE_TO_RAT  = method RAT "valueOf" [ `double ]
MATH_PRIM name = method MATH name [ `double ]

; native: (+) (-) (*) (/) (%) (^)
;         NaN Infinity

e  = 2.718281828459045
pi = 3.141592653589793

abs x = match x
    x : prec = if (x < 0) (-x) else x
    x : real = ABS x

negate x = -x

; TODO signum recip
;      gcd lcm

sqrt  =  MATH_PRIM "sqrt"
ln    =  MATH_PRIM "log" 
sin   =  MATH_PRIM "sin" 
tan   =  MATH_PRIM "tan" 
cos   =  MATH_PRIM "cos" 
asin  =  MATH_PRIM "asin"
atan  =  MATH_PRIM "atan"
acos  =  MATH_PRIM "acos"
ceil  x : num = match x 
    x : real = (MATH_PRIM "ceil") x
    x : rat = (method RAT "ceil" []) x
    x : int = x
floor x : num = match x
    x : real = (MATH_PRIM "floor") x
    x : rat = (method RAT "floor" []) x 
    x : int = x

round  = MATH_PRIM "round" .. LONG_TO_INT
approx = NUM_TO_DOUBLE
rationalize = DOUBLE_TO_RAT

logn n : real = ln .. (* (1. / ln n))
log           = logn 10.
log2          = logn 2.

isOdd      x : num = x % 2 == 1
isEven     x : num = x % 2 == 0
isZero     x : num = match x (0 = true) (0.0 = true) (_ = false)
isPositive x : num = match x (x : prec = x > 0) (x : real = x > 0.0) 
isNegative x : num = match x (x : prec = x < 0) (x : real = x < 0.0)
isNan      x : num = (x == NaN)
isInfinite x : num = (x == Infinity)
isNumber   x : num = not (isNan x)
isFinite   x : num = not (isInfinite x) && not (isNan x)

sum     = foldl (+) 0
product = foldl (*) 1
mean xs = sum xs / length xs



; Lists

; TODO Naive implementations
; TODO Assure all work for strings

; native: prepend head tail

append x = (flip (++)) [x]
last     = foldl second [] . tail
init xs  = match xs
    (x, xs : []) = []
    (x, xs)      = prepend x (init xs)


length   = foldr ((+ 1) .' second) 0
rank xs  = match xs
    _ : [] = 1
    _      = (succ . max . (map
                 fn (xs) match xs
                     _  : []    = 1
                     xs : [ _ ] = rank xs
                     _          = 0)) 
              xs 

isEmpty xs  = match xs
    _ : ()    = true
    _ : [ _ ] = false
isSingle xs = match xs
    _ : ()    = false
    _         = (tail xs) == ()

substr m n = take n . drop m





reverse   = foldl (flip prepend) []
; remove
; retain
; sort
; search

find pred = foldl (fn (x y) if (pred y) y else x) ()
; partition

; shuffle
; permute

randoms n = (map (fn (x) random n) (repeat 1))

repeat    = unfold (fn (x) (x, x))
cycle  xs = xs ++ delay (fn (_) cycle xs)
palindrome xs = let sx = reverse xs
                    xs ++ sx ++ delay (fn (_) palindrome xs)

some  = foldr (||) false
every = foldr (&&) true
none  = not . some

zipWith f xs ys = match [f, xs, ys]
    [ f, (x, xs), (y, ys) ] = prepend (f x y) (zipWith f xs ys)
    [ _, _, _ ]             = ()
                                  

zip3With f xs ys zs = match [f, xs, ys, zs]
    [ f, (x, xs), (y, ys), (z, zs) ] = prepend (f x y z) (zip3With f xs ys zs)
    [ _, _, _, _ ]                   = ()


; lazy!
zipWithL f xs ys = delay (fn (_) 
    prepend 
        f (head xs) (head ys)
        zipWithL f (tail xs) (tail ys))

zip3WithL f xs ys zs = delay (fn (_) 
    prepend 
        f (head xs) (head ys) (head zs)
        zip3WithL f (tail xs) (tail ys) (tail zs))


zip = zipWith (,)
zip3 = zip3With (,)
zipL = zipWithL (,)
zip3L = zip3WithL (,)


dup = foldr (fn (x y) [x, x] ++ y) []

dupL xs = delay 
    fn (_)
        let x = head xs
            [x, x] ++ dupL (tail xs)

; lazy!
interlL xs ys = delay 
    fn (_) 
        let x = head xs
            y = head ys
            [x, y] ++ interlL (tail xs) (tail ys)

interl3L xs ys zs = delay 
    fn (_) 
        let x = head xs
            y = head ys
            y = head zs
            [x, y, zs] ++ interl3L (tail xs) (tail ys) (tail zs)


interp y xs = prepend (head xs) (foldl (fn (zs x) zs ++ [y] ++ [x]) [] (tail xs))




; str -> [a] -> str
join s = foldr (++) "" . interp s . map string

; Force and buffer n values
buffer n xs = force (take n xs) ++ drop n xs
    
bufferStream n xs = force (take n xs) ++ delay (fn (_) bufferStream n (drop n xs))


; native: now random
;         parse print parseFile eval error
;         readFile writeFile
;         repl load quit

version = (method (class "VitryRuntime") "getVersion" []) ()
versionStr = join
    interp "." (map string version)

RANDOM        = class "java.util.Random"
RANDOM_INST   = new RANDOM
RAND_FLOAT    = method RANDOM "nextFloat" ()
    
pick xs       = index (random (length xs)) xs
decide f g x  = match (random 2) (0 = f x) (1 = g x)
randomFloat _ = RAND_FLOAT RANDOM_INST


OBJECT           = class "java.lang.Object"
THREAD_LOCAL     = class "java.lang.ThreadLocal"
THREAD_LOCAL_GET = method THREAD_LOCAL "get" []
THREAD_LOCAL_SET = method THREAD_LOCAL "set" [ OBJECT ]

ref _   = new THREAD_LOCAL
get r   = THREAD_LOCAL_GET r
set r x = 
    do THREAD_LOCAL_SET r x
       r

THREAD_SLEEP = method (class "Thread") "sleep" [ `long ]

sleep time = do time = NUM_TO_LONG time
                THREAD_SLEEP time
                time
    
timer f    = do start = now ()
                f ()
                now () - start
