


ANTLR command:
    java -cp lib/*:bin org.antlr.Tool -fo src/java/vitry/runtime/parse/  src/grammar/Vitry.g 
          


We define the equational logic of Vitry in terms of the following domains and functions:
    
    Term         := Atom 
                  | Product
                  | Union
                  | Set
                  | FunctionType
                  | Type              
    Atom         := Function
                  | Value             
    Product      := Term (, Term)*
    Set          := Term (, Term)*
    Union        := Term (, Term)*
    Intersection := Term (, Term)*
    Type         := (Term, Tag)
    FunctionType := (Term, Term)
    Value        := trivial (numbers, characters etc.)
    Tag          := trivial (a simple identity generated on-the-fly)

    =        : Term -> Term -> Boolean
    :        : Term -> Term -> Boolean
    tag      : Term -> Type -> Term
    getTag   : Term -> Type
    enumerate : (Union|Intersection) -> Set

    - The atom and product types form "concrete" values which may be simple or compound (tuples).

    - The = and : relations represent equality and membership.
      For atoms and sets, the implementation of = is straightforward.
      The : relations is identical to equality for atoms and to membership (over non-sets)/inclusion (over sets) for sets.
      Unions and intersections represents the logical and/or relations applied to sets.
      Products forwards both function to its child elements, to allow recursive structural comparison.
      
    - A structural type is obtained by applying a unique tag to an expression. The resulting
      value can be used to tag any value matching that particular type expression (making
      type checks fast). The semantics of structural types mimic the newtype keyword
      in Haskell.

    - Basically, we have a type system based on constructions (atoms, tuples) and membership (sets, types).
      Intersections and unions may be thought of as lazy sets. There is a function to enumerate (calculate)
      all proper members of a set. This may be non-terminating as unions and tuples may be recursive
      (we have a Turing-complete type system).
    
    - FunctionTypes are a simply a pair, used to represent to domain and codomain of function
      instances. Higher-arity functions are represented as curried functions. These can of course be
      converted to functions operating on tuples and vice versa.
     
    - We use the standard recursive representation for sequences, i.e. (a,(b,c,())) etc.        
            
    = is an equivalence relation
    : is a partial ordering
    
    Z := S ∪ U ∪ I

    (a = b) iff (a ∈ A, b ∈ A, trivially)
              | (a ∈ P, b ∈ P, a =~ b)
              | (a ∈ Z, b ∈ Z, a : b ∪ b : a )
    
    (a : b) iff (a ∈ A, b ∈ A, a = b)
              | (a ∈ P, b ∈ P, a :~ b)
              
              | (a ∈ (A ∪ P), b ∈ S, ∃x (x ∈ b,   a = x)) 
              | (a ∈ (A ∪ P), b ∈ U, ∃x (x ∈ b,   a : x)) 
              | (a ∈ (A ∪ P), b ∈ I, ∀x (x ∈ b -> a : x))
              
              | (a ∈ S, b ∈ Z,       ∀x (x ∈ a -> x : b)) 
              | (a ∈ U, b ∈ Z,       ∀x (x ∈ a -> x : b)) 
              | (a ∈ I, b ∈ (S ∪ U), ∃x (x ∈ a,   x : b))
              
              | (a ∈ I, b ∈ I,       ∀x (x ∈ b -> a : x))
              | (a ∈ I, b ∈ (A ∪ P), ∃x (x ∈ a,   x : b))
       
    
    - Should a pattern match isomorphic types?
        - For example is this legal?
            type age = nat
            match (2 : age) 
              nat ()
              else error

        
        


- AST

    expr   = module | fn |
             Let | where | assign | left |
             apply | type | if | match | loop | recur

    module = (name:str, exports:[str], imports:[str], members:[assign])
    fn     = (params:[left], body:expr)

    let    = (assigns:[assign], body:expr)
    where  = (assigns:[assign], body:expr)
    assign = (left:left, right:expr)            -- the = sign
    left   = expr
    quote  = expr                               -- the ` sign

    apply  = (fn:expr, args:[expr])
    type   = (value:expr, type:expr)            -- the : sign
    if     = (cond:expr, alt1:expr, alt2:expr)
    match  = (cond:[left], case:[expr], val:expr)
    loop   = ([assign], body:expr)
    recur  = (args:[expr])
    do     = (assigns:[assign], [expr])
    
    
    
    
--------


Internal reification API:

-- ariadic types such as ConcList n and Tree n are really dependent. We should have some magic to generate
-- actual java classes here.

type [a]          = list a                        
type list a       = (a, list a) | ()
type revList a    = (a, revList a, revList a) | ()
type concList a   = (concList a , concList a) | a
type concList n a = (concList n a , concList n a, ... concList n a) | single a
type single a     = a                                                                              

type listTree a   = (a, [listTree a])           | leaf a
type tree a       = (a, tree a, tree a)         | leaf a
type tree n a     = (a, tree n a, ... tree n a) | leaf a
type revTree a    = (a, revtree a, [revTree a]) | leaf a
type leaf a       = a

type digraph a    = (a, [digraph a])
type revDigraph a = (a, digraph a, [digraph a])


`, : a b ... -> (a, b ...)

reify   : 
        ( [a]
        | revList a
        | concList a
        | concList n a
        | listTree a
        | tree a
        | tree n a
        | revTree a
        | digraph a
        | revDigraph a
        ) -> (a, a, ...)

list    : (a, a, ...) -> [a]
revList : (a, a, ...) -> revList a
    etc. 

-- Some meta info:

isReversible   : (a, ...) -> bool
isParallel     : (a, ...) -> bool
isSequential   : (a, ...) -> bool
representation : (a, ...) -> type


-- The basic function comma/product constructs products from any given number of arguments.
-- The naive implementation is to make a pair (cons) and use a primitive to convert lists to functions.
-- Efficient implementations may use native triples, quadruples etc.
-- Basically the number of tree children is orthogonal to the number represented. We *could* represent
-- any value as a Lisp-cons (1-tree), as a binary tree (2-tree), or as a Clojure vector (17-tree)     
-- After that, we only need to convert products to sets/unions/intersections

-- How to let the user supply product and list implementations? Implicit conversions? Typeclasses?
