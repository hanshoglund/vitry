                 
Move general info to NOTES, gradually move this stuff to tracker.

====================================================================================================


- Implement a core language
    - Type system                   
    - Lexer/Parser, Interpreter, Compiler, Runtime  


    
- Type system
    - Special types to match nat, int etc.
    - We will need some kind of distributive rewriting on Products/FunctionTypes vs. Unions
      for the implementation of method overloading

    -   
                                    
        - Retagging: OK if the old type includes the new ("narrowing conversion")
        - See test/js for test scases
        
    java implementation:
        - We allow any java object for Atoms
            - Object.equals represent =
            - Object.toString represent the show function
        - Basic value classes:
            BigInteger  <=> nat
            BigInteger  <=> int
            String      <=> string
            v.p.Symbol  <=> symbol
            Float       <=> float
            Double      <=> double



- Compiler
    - Current implementation too ugly
    - New strategy: 
        - Implement data structures first
        - Do parsing as multistage traversal, using internal match
            - Pass 1: Resolve symbols (replace local lookups etc)
            - Pass 2: Generate compilation tree/DG
                - Class gen node
                - Branch node
                - Standard snode
            - Convert to bytecode


- Runtime                                  
    - The "VitrySystem" class provides static methods to create systems
        - Thus Java primitives may use several systems on the same JVM

    - A system is a set of loaded modules
        - Each module is a callable that when called generates
          a top environment containing functions/types/values
        - The  class loader provides an internal "import" function 
          that load other modules as needed, then copy the selected 
          members to the importer.
        - In case of recursive dependency, store incomplete modules,
          set unresolvable field to null, and make reattempt.  
    implementation:
        The ModuleClassLoader can works like a persistent collection that
        can "unload" modules, by manufacturing a version of itself in
        which the unloaded module is not present. 
          
    - For the REPL, we actually replace the top-level for each command,
      persistantly copying previous assignments. (Required to prevent
      repeated assignments in the same command block).  
        - Modules may not be defined on the REPL, however, fns and other
          class generators may.
        - To load callables generated on the REPL, we need to generate a dummy
          class that automatically interprets some encapsulated code.
      
    implementation:      
      
      - A ModuleClassLoader can load modules (i.e. classes named $.class)
        and resolve their bindings. Thus a MCL can easily encapsulate an
        entire Vitry system.                     
           - Classes may be loaded from the $CLASSPATH. To provide 
             alternative ways of loading, simply hoist some custom CL
             as parent of the  MCL instead of using the SystemCL.
           - vitry.primitive should be available from the SystemCL         
           - Standard Stack:
            
            JVM
              BoostrapCL
              ExtensionCL
              SystemCL
                class VitrySystem
                  instance0          
                    ...
                    ModuleClassLoader
                  ...
                  instanceN
           
               - For the REPL ... ?

    important:
    - VitrySystem must not use *any* static state as this would be visible
      from concurrently running systems.

    
- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions (invokevirtual) by default
        - Others may be added for TCO, see Compiler
    - Semantically, all functions are unary and curried
    - Implementation-wise, however, the following invariants hold:
        - A function is an object that inherits from vitry.p.Function
        - A function has the following properties
            - An environment (implicit)
            - Arity, defined by Function.arity()
            - Type, defined by Function.type()
            - Body, defined by Function.invoke()                                 

        - Whenever a function f is called with N arguments:
            if not f instanceof RestArgFunction
                if  N   < f.arity,  then a partial application is returned
                if  N   = f.arity,  then f(a1,a2..a[N]) is returned
                if  N+1 = f.arity,  then f(a1,a2..a[N-1]) f[N] is returned
                if  N+2 = f.arity,  then f(a1,a2..a[N-2]) f[N-1] f[N] is returned
                etc.
            else
                if  N < f.arity,  then a partial application is returned
                if  N = f.arity,  then f(a1,a2..a[N]) is returned
                if  N > f.arity,  then f(a1,a2..a[f.arity], rest) is returned, where rest is an array containing a[f.arity]...a[N]
                
    - See the eval/apply method in "Making a Fast Curry"

    - Top level "overloaded" function delcarations such as
        add a:int b:int
        add as:[int]
    are converted to RestArgFunctions of arity 0 containing a *match* expression (or native equivalent).



- Lists (!)
    - We should represent lists as functions returning types, i.e.
        list a = type a, (list a |Â ())
        `[] a  = type a, [a] | ()
        Here assuming that | has higher predecence than ,
    - We should probably do most of this in java for efficiency           

- Records
    - Straight tuples
    - Unlike Haskell, no special lookup functions, instead we use the type (just as we support untagged unions)
    - Lookup functions simply does the following + memoization
        (match map
          (key,_,_)
          (_,key,_)
          (_,_,key))
    - The record function can tag/retag values to support user-defined "keys"
    - As these tags are equivalent to the actual type of the value, they do not cause any problems when
      the value is looked up


====================================================================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Proper tail-call opt
- Kinds (library level)
- Macros/user defined syntax

