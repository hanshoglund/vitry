

- Implement a core language
    - Type system                   
    - Lexer/Parser, Interpreter, Compiler, Runtime  


    
- Type system
    - We define the equational logic of Vitry in terms of the following domains and functions:
        
        Term         := Atom 
                      | Product
                      | Union
                      | Set
                      | FunctionType
                      | Type              
        Atom         := Function
                      | Value             
        Product      := Term (, Term)*
        Set          := Term (, Term)*
        Union        := Term (, Term)*
        Intersection := Term (, Term)*
        Type         := (Term, Tag)
        FunctionType := (Term, Term)
        Value        := trivial (numbers, characters etc.)
        Tag          := trivial (a simple identity generated on-the-fly)

        =        : Term -> Term -> Boolean
        :        : Term -> Term -> Boolean
        tag      : Term -> Type -> Term
        getTag   : Term -> Type
        enumerate : (Union|Intersection) -> Set

        - The atom and product types form "concrete" values which may be simple or compound (tuples).

        - The = and : relations represent equality and membership.
          For atoms and sets, the implementation of = is straightforward.
          The : relations is identical to equality for atoms and to membership (over non-sets)/inclusion (over sets) for sets.
          Unions and intersections represents the logical and/or relations applied to sets.
          Products forwards both function to its child elements, to allow recursive structural comparison.
          
        - A structural type is obtained by applying a unique tag to an expression. The resulting
          value can be used to tag any value matching that particular type expression (making
          type checks fast). The semantics of structural types mimic the newtype keyword
          in Haskell.

        - Basically, we have a type system based on constructions (atoms, tuples) and membership (sets, types).
          Intersections and unions may be thought of as lazy sets. There is a function to enumerate (calculate)
          all proper members of a set. This may be non-terminating as unions and tuples may be recursive
          (we have a Turing-complete type system).
        
        - FunctionTypes are a simply a pair, used to represent to domain and codomain of function
          instances. Higher-arity functions are represented as curried functions. These can of course be
          converted to functions operating on tuples and vice versa.
         
        - We use the standard recursive representation for sequences, i.e. (a,(b,c,())) etc.        
                
        = is an equivalence relation
        : is a partial ordering
        
        Z := S ∪ U ∪ I

        (a = b) iff (a ∈ A, b ∈ A, trivially)
                  | (a ∈ P, b ∈ P, a ~ b)
                  | (a ∈ Z, b ∈ Z, a : b ∪ b : a )
        
        (a : b) iff (a ∈ A, b ∈ A, a = b)
                  | (a ∈ P, b ∈ P, a = b)
                  | (a ∈ (A ∪ P), b ∈ S, ∃x (x ∈ b,   a = x)) 
                  | (a ∈ (A ∪ P), b ∈ U, ∃x (x ∈ b,   a : x)) 
                  | (a ∈ (A ∪ P), b ∈ I, ∀x (x ∈ b -> a : x)) 
                  | (a ∈ S, b ∈ Z, ∀x (x ∈ a -> x : b)) 
                  | (a ∈ U, b ∈ Z, ∀x (x ∈ a -> x : b)) 
                  | (a ∈ I, b ∈ Z, ∃x (x ∈ a,   x : b))
           
        
        - Should a non-type match isomorphic types?
            - For example 
                if age = Type(nat), does Contains(nat, (2 : age)) hold?
                
            - Subtyping.
            - Problem: generic functions (i.e. add, map) should preserve type integrity.
            - Intuitively, it seems better to simulate covariants as sets/subsets.  
                                    
        - Retagging: OK if the old type includes the new ("narrowing conversion")
        - See test/js for test scases
        
    java implementation:
        - We allow any java object for Atoms
            - Object.equals represent =
            - Object.toString represent the show function
        - Basic value classes:
            BigInteger  <=> nat
            BigInteger  <=> int
            String      <=> string
            v.p.Symbol  <=> symbol
            Float       <=> float
            Double      <=> double

        - Other values implement the Pattern interface
            - Pattern.matches represent : on types
            - The compiler inserts a check to represent : on other objects
              PROBLEM: What about types matching primitives (i.e. nat)
                
        - ISSUES:
            - The Product/Set/Union/Intersection implementations of eq/matches are orthogonal to the problem
              of tree representation (linked, fibbonaci heap, hashed, tries)
                - Double dispatch on eq/matches.
                - Goals: 
                    - Allow for various implementations of eq/matches
                    - Allow for various implementations of traversal
                    - No call overhead for iteration
                - Solution: 
                    - Value :> (P|S|U|I) is an interface hierarchy
                    - Implementations of PSUI derive from AbstractSeq (allowing for various
                      sequencable representations).
                    - equals is implemented on AbstractPattern
                    - Pattern is implemented by a visitor, where the visitor is right side of 
                      the : expression and the acceptor is the left (reverse?)
                    
            - Product and Union must have lazy counterparts (to support lazy lists)
                - Solution: define a Sequence interface that extends Iterable : first() and rest()
            
        E.g.
        LinkedPattern
            matches(PatternMatcher v) <-dispatch right (pattern/matcher)
                v.match(this)         <-overload left (matching)
            
            
        - OVERVIEW:
            interface Env (define, lookup, fetch)
                class AbstractEnv
        
            interface Pattern (matches/accept)
            interface Value
                interface Atom
                    abstract Callable
                        class Function
                interface Product <: Pattern
                interface Set <: Pattern
                interface Union <: Pattern
                interface Intersection <: Pattern
                interface Type <: Pattern
                interface FunctionType <: Pattern
                class Wildcard <: Pattern
                class Reference
            interface Seq (head, tail)
                abstract AbstractPattern (equals, accept)
                    abstract LinkedPattern
                        class LinkedProduct <: Product
                        class LinkedSet <: Product
                        class LinkedUnion <: Union
                        class LinkedIntersection <: Intersection
                    abstract FibheapPattern
                        [...]
            PatternMatcher  (matchAtom, matchProduct, matchUnion...)
                class ProductMatcher
                class UnionVisitor
                class IntersectionVisitor
                class TypeVisitor
                class FunctionTypeVisitor  

    



- Compiler
    - Current implementation too ugly
    - New strategy: 
        - Implement data structures first
        - Do parsing as multistage traversal, using internal match
            - Pass 1: Resolve symbols (replace local lookups etc)
            - Pass 2: Generate compilation tree/DG
                - Class gen node
                - Branch node
                - Standard snode
            - Convert to bytecode
            


- Runtime                                  
    - The "VitrySystem" class provides static methods to create systems
        - Thus Java primitives may use several systems on the same JVM

    - A system is a set of loaded modules
        - Each module is a callable that when called generates
          a top environment containing functions/types/values
        - The  class loader provides an internal "import" function 
          that load other modules as needed, then copy the selected 
          members to the importer.
        - In case of recursive dependency, store incomplete modules,
          set unresolvable field to null, and make reattempt.  
    implementation:
        The ModuleClassLoader can works like a persistent collection that
        can "unload" modules, by manufacturing a version of itself in
        which the unloaded module is not present. 
          
    - For the REPL, we actually replace the top-level for each command,
      persistantly copying previous assignments. (Required to prevent
      repeated assignments in the same command block).  
        - Modules may not be defined on the REPL, however, fns and other
          class generators may.
        - To load callables generated on the REPL, we need to generate a dummy
          class that automatically interprets some encapsulated code.
      
    implementation:      
      
      - A ModuleClassLoader can load modules (i.e. classes named $.class)
        and resolve their bindings. Thus a MCL can easily encapsulate an
        entire Vitry system.                     
           - Classes may be loaded from the $CLASSPATH. To provide 
             alternative ways of loading, simply hoist some custom CL
             as parent of the  MCL instead of using the SystemCL.
           - vitry.primitive should be available from the SystemCL         
           - Standard Stack:
            
            JVM
              BoostrapCL
              ExtensionCL
              SystemCL
                class VitrySystem
                  instance0          
                    ...
                    ModuleClassLoader
                  ...
                  instanceN
           
               - For the REPL ... ?

    important:
    - VitrySystem must not use *any* static state as this would be visible
      from concurrently running systems.


    
    

- Parser and Lexer (already in ANTLR proj)    


                


    
- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions (invokevirtual) by default
        - Others may be added for TCO, see Compiler
    - Semantically, all functions are unary and curried
    - Implementation-wise, however, the following invariants hold:
        - A function is an object that inherits from vitry.p.Function
        - A function has the following properties
            - An environment (implicit)
            - Arity, defined by Function.arity()
            - Type, defined by Function.type()
            - Body, defined by Function.invoke()                                 

        - Whenever a function f is called with N arguments:
            if not f instanceof RestArgFunction
                if  N   < f.arity,  then a partial application is returned
                if  N   = f.arity,  then f(a1,a2..a[N]) is returned
                if  N+1 = f.arity,  then f(a1,a2..a[N-1]) f[N] is returned
                if  N+2 = f.arity,  then f(a1,a2..a[N-2]) f[N-1] f[N] is returned
                etc.
            else
                if  N < f.arity,  then a partial application is returned
                if  N = f.arity,  then f(a1,a2..a[N]) is returned
                if  N > f.arity,  then f(a1,a2..a[f.arity], rest) is returned, where rest is an array containing a[f.arity]...a[N]
                
    - See the eval/apply method in "Making a Fast Curry"

    - Top level "overloaded" function delcarations such as
        add a:int b:int
        add as:[int]
    are converted to RestArgFunctions of arity 0 containing a *match* expression (or native equivalent).



- Lists (!)
    - We should represent lists as functions returning types, i.e.
        list a = type a, (list a | ())
        `[] a  = type a, [a] | ()
        Here assuming that | has higher predecence than ,
    - We should probably do most of this in java for efficiency           

- Records
    - Straight tuples
    - Unlike Haskell, no special lookup functions, instead we use the type (just as we support untagged unions)
    - Lookup functions simply does the following + memoization
        (match map
          (key,_,_)
          (_,key,_)
          (_,_,key))
    - The record function can tag/retag values to support user-defined "keys"
    - As these tags are equivalent to the actual type of the value, they do not cause any problems when
      the value is looked up


==================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Proper tail-call opt
- Kinds (library level)
- Macros/user defined syntax

