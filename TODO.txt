
- Implement a very simple core language in Java (vitry.primitive)
    - Contains notions of Type, Value and Function
    - AST etc is handled by ANTRL
        - AST nodes are values in the language
                                               
    - Implement basic eq logic in Value and subtypes 
    - Implement classes Util, Core, Compiler
    
    
                
- Semantics of the eq logic
    - Notions of equality and type membership
    - Power types, unions and functions
    - What about:
        - "Concrete" vs "abstract" values
        - Representation of 1-tuple
        - Type tagging

    - Basic relations
        - Equality
        - Type membership (informally "matches" , "has type", "has value")
        
        - Java implementation:
            - Equality is Object.equals() with the same semantics
            - Type memebership is Value.hasValue()
            - Problem : we may want to use other classes (i.e. Boolean, Float, Double)
            - Does not this make the implentation less than straightforward? Every time we pass a
            value, we must overload that method with an Object.
            - The benefit of manipulating the value graph directly is great for future 
            optimization and crucial to define type operations. If we were to refactor this to other
            classes, what happens?
            - I would much prefer to keep everything a vitry.p.Value subclass and add the possibility
            of primitives (in a restricted sense) later on.
               

- Symbols
    - Symbols should just be identifiers, regardless of context 
    - We use only statically/lexically scoped references
        - We rewrite *all* expressions (including modules etc) as functions/let bindings and resolve all identifiers directly.
        - No dynamic "environment" as in Scheme
        
- Lazy evalutations
    - The compiler may add thunks, i.e. concrete implementations of vitry.p.Thunk
    
- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions, i.e. invokevirtual
    - Semantically, all functions are unary and curried
    - Implementation-wise, however, the following invariants hold:
        - A function is an object that inherits from vitry.p.Function
        - A function has the following properties
            - Arity, defined by Function.getArity()
            - Type, defined by Function.getType()
            - Body                                 
        - For any function f, f.arity
        - Whenever a function f is called with N arguments:
            if not f instanceof RestArgFunction
                if  N   < f.arity,  then a partial application is returned
                if  N   = f.arity,  then f(a1,a2..a[N]) is returned
                if  N+1 = f.arity,  then f(a1,a2..a[N-1]) f[N] is returned
                if  N+2 = f.arity,  then f(a1,a2..a[N-2]) f[N-1] f[N] is returned
                etc.
            else
                if  N < f.arity,  then a partial application is returned
                if  N = f.arity,  then f(a1,a2..a[N]) is returned
                if  N > f.arity,  then f(a1,a2..a[f.arity], rest) is returned, where rest is an array containing a[f.arity]...a[N]
                
    - See the eval/apply method in "Making a Fast Curry"

    - Top level "overloaded" function delcarations such as
        add a:int b:int
        add as:[int]
    are converted to RestArgFunctions of arity 0 containing a *match* expression (or native equivalent).
    
    
- Special forms
    - The JVM disallows non-local jumps (?)
        - Good for conceptual purity
    - We implement match statements as "switches" using local jumps
    - We implement loop/recur as well as self-call (thorugh recur) as a goto into the function head
        - Basically, at recur position we push the new values to the arguments and jumps
            - Meaning: no tail-call opt for indirect self-recursion (a la Clojure)
                - Possible alternative, the mini-interpreter (see NestedVM, kawa?)    


- Lists (!)
    - We should represent lists as functions returning types, i.e.
        list a = type a, (list a |Â ())
        `[] a  = type a, [a] | ()
        Here assuming that | has higher predecence than ,
    - We should probably do most of this in java for efficiency
    
- Maps (i.e. simple functions)



==================================================
Vitry Intermediate code (VIC)

VIC is an intermediate format for Vitry, used to implement closures and lazy evaluation

Characteristics:
    - Just a data structure, no binary representation. May easily be translated to JVM bytecode.
    - Reference types only (we will add primitives later).
    - May create and invoke functions and/or thunks.
    - Variables may be of type local and shared. The latter form is used to implement closure.
    - Supports nested instructions (functions and thunks). These are implemented as different JVM classes and a new instruction
      in the enclosing function.

Notation:

Instructions are on the form:
    name operand* (instruction*)

    load    
            Load a local variable to the stack.
    store   
            Store a local variable from the stack.
    
    func    
            Creates an instance of the (generated) function, assure closure bindings are copied or made accessible and push it.
            We implement closures just as in java, i.e. required bindings are passed to the <init> method and stored in val$N where N is the name of the binding.
             
    thunk   
            Creates an instance of the (generated) thunk,  assure closure bindings are copied or made accessible and push it.

    invoke  fn args ...    
            Invoke a function from the top of the stack, using N arguments from the stack.
            If given too few arguments, return a partially applied function.
            If given too many arguments, return the application (((f aN) aN+1) ... aN+i).
            If one argument or more is a thunk and evaluation is not forced, wrap in a thunk.
    
    force   th
            Force evaluation of a thunk from the stack.

    

We write "nested declarations" like this

function (
    X
    X
    thunk (
    
    )
)


Examples:  

    
                                                                                             


Translation:

Any list of VIC instructions may be translated to a JVM class, subclassing vitry.p.Function, where the JVM instructions form the body of the invoke() method.


==================================================
JVM op cheat sheet

aconst_null
aload
aload_<n>
areturn
astore
astore_<n>
athrow
dup
dup_x1
dup_x2
dup2
dup2_x1
dup2_x2  
getfield
getstatic
goto
goto_w  
if_acmp_<cond>       
if<cond>
ifnonnull
ifnull
instanceof
invokeinterface
invokespecial
invokestatic
invokevirtual
jsr
jsr_w
lookupswitch    
lcd      
lcd_w
monitorenter
monitorexit
multianewarray
new
nop
pop
pop2
putfield
putstatic
swap
tableswitch
wide


==================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Kinds (library level)
- Macros/user defined syntax

