

- Implement a core language
    - Type system                   
    - Lexer/Parser, Interpreter, Compiler, Runtime  



    
- Type system
    - We define the equational logic of Vitry in terms of the following domains and functions:
        
        Term         := Atom 
                      | Product
                      | Union
                      | Set
                      | FunctionType
                      | Type              
        Atom         := Function
                      | Value             
        Product      := head:Term tail:(, Term)*
        Union        := head:Term tail:(, Term)*
        Set          := head:Term tail:(, Term)*
        Type         := (Term, Tag)
        FunctionType := (Term, Term)
        Value        := trivial (numbers, characters etc.)
        Tag          := trivial (a simple identity generated on-the-fly)

        =        : Term -> Term -> Boolean
        :        : Term -> Term -> Boolean
        tag      : Term -> Type -> Term
        getTag   : Term -> Type

        - The atom and product types form "concrete" values which may be simple or compound (tuples).

        - The = and : relations represent equality and membership.
          For atoms and sets, the implementation of = is straightforward.
          The : relations is identical to equality for atoms and to membership (over non-sets)/inclusion (over sets) for sets.
          Unions and intersections represents the logical and/or relations applied to sets of values.
          Products forwards both function to its child elements, to allow recursive structural comparison.
        
        - A structural type is obtained by applying a unique tag to an expression. The resulting
          value can be used to tag any value that matches that particular type expression (making
          type checks safe and fast). The semantics of structural types mimic the newtype keyword
          in Haskell.
        
          FunctionTypes are a specially marked pair, used to represent to domain and codomain of
          function instances. Higher-arity functions are represented as curried functions.
         
        - We use the standard recursive representation for sequences, i.e. (a,(b,c,())) etc.        
        
        
        = is an equivalence relation
            x:Atom = y:Atom        
                trivial                
            
            x:Product = y:Product
                iff x = () and y = () or
                    head(x) = head(y) and tail(x) = tail(y)

            x:Set = y:Set
                iff x : y and y : x

            x:Union = y:Union                  
                iff x : y and y : x

            x:Intersection = y:Intersection
                iff x : y and y : x
            
            
        : is a partial order
            x:Value (:)  
            y:Value
                iff x = y
            
            x:Product (:)  
            y:Product
                iff x = y or
                    head(x) : head(y) and tail(x) : tail(y)

            
            x:(Atom|Product) (:)  
            y:Set
                iff x = head(y) or x = tail(y)
            
            x:(Atom|Product) (:)  
            y:Union
                iff x : head(y) or x : tail(y)

            x:(Atom|Product) (:)  
            y:Intersection
                iff x : head(y) and x : tail(y)

            
            x:Set  (:)
            y:Set    
                iff for each element E in x, E = head(y) or E = tail(y)

            x:Set (:)  
            y:Union  
                iff for each element E in x, E : head(y) or E : tail(y)

            x:Set  (:)  
            y:Intersection
                iff for each element E in x, E : head(y) and E : tail(y)
                
            
            x:Union (:)  
            y:Set             
                enumeration?
            
            x:Union (:)  
            y:Union
                iff for each element E in x, E : head(y) or head(y) : E or E : tail(y) or tail(y) : E
                
            x:Union (:)  
            y:Intersection
                rewriting?
                           
            x:Intersection (:)
            y:(Atom|Product)
                iff y : head(x) or head(x) : y or y : tail(x) or tail(x) : y  

            x:Intersection (:)  
            y:Set
                enumeration?
            
            x:Intersection (:)  
            y:Union
                rewriting?

            x:Intersection (:)  
            y:Intersection
                iff for each element E in y, head(x) : E or tail (x) : E

           
        
        - Should a non-type match isomorphic types?
            - For example 
                if age = Type(nat), does Contains(nat, (2 : age)) hold?
                
            - Subtyping.
            - Problem: generic functions (i.e. add, map) should preserve type integrity.
            - Intuitively, it seems better to simulate covariants as sets/subsets.  
            
        - Some cases that should hold:
            a = a
            (a,b) = (a,b)
            (a,(b,c)) = (a,(b,c))
            a|(b|c) = (a|b)|c
            a & (a & a) = (a & a) & a
            {a,b,c} = {a,b,c}
            a,b,c : a,b,c
            a : a|b|c
            b : a|b|c
            c : a|b|c
            a : a|(b|c)
            b : a|(b|c)
            c : a|(b|c)
            a : {a,b,c} 
            b : {a,b,c} 
            c : {a,b,c}
            a : {a,{b,c}}
            {b, c} : {a,{b,c}}     
            {a,b} : (a|b)
            {a} : a & a
            (a|b) : (a|b) & (a|b)

    
- Compiler
    - Current implementation too ugly
    - New strategy: 
        - Implement data structures first
        - Do parsing as multistage traversal, using internal match
            - Pass 1: Resolve symbols (replace local lookups etc)
            - Pass 2: Generate compilation tree/DG
                - Class gen node
                - Branch node
                - Standard snode
            - Convert to bytecode
            


- Runtime                                  
    - The "VitrySystem" class provides static methods to create systems
        - Thus Java primitives may use several systems on the same JVM

    - A system is a set of loaded modules
        - Each module is a callable that when called generates
          a top environment containing functions/types/values
        - The  class loader provides an internal "import" function 
          that load other modules as needed, then copy the selected 
          members to the importer.
        - In case of recursive dependency, store incomplete modules,
          set unresolvable field to null, and make reattempt.  
    implementation:
        The ModuleClassLoader can works like a persistent collection that
        can "unload" modules, by manufacturing a version of itself in
        which the unloaded module is not present. 
          
    - For the REPL, we actually replace the top-level for each command,
      persistantly copying previous assignments. (Required to prevent
      repeated assignments in the same command block).  
        - Modules may not be defined on the REPL, however, fns and other
          class generators may.
        - To load callables generated on the REPL, we need to generate a dummy
          class that automatically interprets some encapsulated code.
      
    implementation:      
      
      - A ModuleClassLoader can load modules (i.e. classes named $.class)
        and resolve their bindings. Thus a MCL can easily encapsulate an
        entire Vitry system.                     
           - Classes may be loaded from the $CLASSPATH. To provide 
             alternative ways of loading, simply hoist some custom CL
             as parent of the  MCL instead of using the SystemCL.
           - vitry.primitive should be available from the SystemCL         
           - Standard Stack:
            
            JVM
              BoostrapCL
              ExtensionCL
              SystemCL
                class VitrySystem
                  instance0          
                    ...
                    ModuleClassLoader
                  ...
                  instanceN
           
               - For the REPL ... ?

    important:
    - VitrySystem must not use *any* static state as this would be visible
      from concurrently running systems.


    
    

- Parser and Lexer (already in ANTLR proj)    


                


    
- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions (invokevirtual) by default
        - Others may be added for TCO, see Compiler
    - Semantically, all functions are unary and curried
    - Implementation-wise, however, the following invariants hold:
        - A function is an object that inherits from vitry.p.Function
        - A function has the following properties
            - An environment (implicit)
            - Arity, defined by Function.arity()
            - Type, defined by Function.type()
            - Body, defined by Function.invoke()                                 

        - Whenever a function f is called with N arguments:
            if not f instanceof RestArgFunction
                if  N   < f.arity,  then a partial application is returned
                if  N   = f.arity,  then f(a1,a2..a[N]) is returned
                if  N+1 = f.arity,  then f(a1,a2..a[N-1]) f[N] is returned
                if  N+2 = f.arity,  then f(a1,a2..a[N-2]) f[N-1] f[N] is returned
                etc.
            else
                if  N < f.arity,  then a partial application is returned
                if  N = f.arity,  then f(a1,a2..a[N]) is returned
                if  N > f.arity,  then f(a1,a2..a[f.arity], rest) is returned, where rest is an array containing a[f.arity]...a[N]
                
    - See the eval/apply method in "Making a Fast Curry"

    - Top level "overloaded" function delcarations such as
        add a:int b:int
        add as:[int]
    are converted to RestArgFunctions of arity 0 containing a *match* expression (or native equivalent).



- Lists (!)
    - We should represent lists as functions returning types, i.e.
        list a = type a, (list a | ())
        `[] a  = type a, [a] | ()
        Here assuming that | has higher predecence than ,
    - We should probably do most of this in java for efficiency           

                                                                                             


==================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Proper tail-call opt
- Kinds (library level)
- Macros/user defined syntax

