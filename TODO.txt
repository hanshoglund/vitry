

- Implement a simple core language
    - Type system                   
    - Lexer/Parser, Interpreter, Compiler, Runtime

          
- Semantics of the eq logic
    - Two basic relations:
        - Equals
        - Contains/MemberOf

    - Power types, unions and functions
    - What about:
        - "Concrete" vs "abstract" values
        - Representation of 1-tuple
        - Type tagging
        
    - Java implementation:
        - Equality is Object.equals() with the same semantics
            - We strive to minimate duplicate objects to save memory and shorten comparison time
        - Type memebership is Value.memberOf()

- Destructuring and type matching
    - How to combine?


- Runtime
    - Think through
        - Class loader strategy
        - Where to store value graph
        - Thread support

- DynamicClassLoader 

- Parser and Lexer (already in ANTLR proj)    

- Pre-compiler
    - Module rewrite (the match trick)
                           
- Compiler
    - Add BranchingEmitter (see that it will work for TCO strategies as well...)
    - Implement (most) compile methods
    - Implement Evaluator properly
    - TEST!

                


    
- Functions
    - Extends vitry.p.Function
    - We use Java calling conventions (invokevirtual) by default
        - Others may be added for TCO, see Compiler
    - Semantically, all functions are unary and curried
    - Implementation-wise, however, the following invariants hold:
        - A function is an object that inherits from vitry.p.Function
        - A function has the following properties
            - An environment (implicit)
            - Arity, defined by Function.getArity()
            - Type, defined by Function.getType()
            - Body, defined by Function.invoke()                                 

        - Whenever a function f is called with N arguments:
            if not f instanceof RestArgFunction
                if  N   < f.arity,  then a partial application is returned
                if  N   = f.arity,  then f(a1,a2..a[N]) is returned
                if  N+1 = f.arity,  then f(a1,a2..a[N-1]) f[N] is returned
                if  N+2 = f.arity,  then f(a1,a2..a[N-2]) f[N-1] f[N] is returned
                etc.
            else
                if  N < f.arity,  then a partial application is returned
                if  N = f.arity,  then f(a1,a2..a[N]) is returned
                if  N > f.arity,  then f(a1,a2..a[f.arity], rest) is returned, where rest is an array containing a[f.arity]...a[N]
                
    - See the eval/apply method in "Making a Fast Curry"

    - Top level "overloaded" function delcarations such as
        add a:int b:int
        add as:[int]
    are converted to RestArgFunctions of arity 0 containing a *match* expression (or native equivalent).



- Lists (!)
    - We should represent lists as functions returning types, i.e.
        list a = type a, (list a |Â ())
        `[] a  = type a, [a] | ()
        Here assuming that | has higher predecence than ,
    - We should probably do most of this in java for efficiency
                                                                                             


==================================================
Future (i.e. much later) work: 

- Simple database routine (via JDBC) for configuratione etc.
- Project management (working with git)
- Build system on top of ANT
- Primitives
- Proper tail-call opt
- Kinds (library level)
- Macros/user defined syntax

